---
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 NumFOCUS

import BasePage from '@awesome-myst/myst-awesome/layouts/BasePage.astro';
import SearchDialog from '../../../components/SearchDialog.astro';
import NavigationMenu from '@awesome-myst/myst-awesome/components/NavigationMenu.astro';

import Authors from '../../../components/Authors.astro';
import Header from '../../../components/Header.astro';
import Footer from '../../../components/Footer.astro';

import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import { Image } from 'astro:assets';
import type { ImageMetadata } from 'astro';

function generatePageUrl(id: string): string {
  return `/browse/publication/${id}`;
}

export async function getStaticPaths() {
  try {
    console.log('Starting getStaticPaths for [id].astro');

    const pages = await getCollection('pages');
    const projectConfig = (await getCollection('projectFrontmatter'))[0];

    console.log(`Total pages found: ${pages.length}`);

    const paths = pages.map((page, index) => {
      const id = page.id;

      console.log(`Processing page ${index + 1}: "${page.id}"`);
      console.log('Page contents:', page);

      return {
        params: { id },
        props: { page: page.data },
      };
    });

    console.log(`Generated ${paths.length} paths for [id].astro`);
    paths.forEach((path, i) => {
      console.log(`  Path ${i + 1}: id="${path.params.id}"`);
    });

    return paths;
  } catch (error) {
    console.error('Error in [id].astro getStaticPaths:', error);
    return [];
  }
}

interface PageProps {
  page: CollectionEntry<'pages'>;
}

const { page } = Astro.props as PageProps;

const allPages = await getCollection('pages');

console.log('page', page)

const title = page?.frontmatter?.title || 'Publication';
const abstract = page?.frontmatter?.abstract || '';
const frontmatter = page?.frontmatter;
const downloads = page?.downloads || [];

// Get the publication ID from the URL params
const publicationId = Astro.params.id;

// Check if any PDF file exists in downloads
const hasPdfFile = downloads.some((d: any) =>
  d.title &&
  typeof d.title === 'string' &&
  d.title.toLowerCase().endsWith('.pdf')
);

const foldersOption = false;
const baseDir = "/";
const showToc = typeof page.mdast.children !== "undefined";

import "../../../styles/custom.css";
import "highlight.js/styles/github-dark.css";

import { mystParseAndRender } from '@awesome-myst/myst-awesome/lib/render-myst-ast';

// Get prev/next pages for navigation
const currentIndex = allPages.findIndex(p => p.id === page.id);
const prevPage = currentIndex > 0 ? allPages[currentIndex - 1] : null;
const nextPage = currentIndex < allPages.length - 1 ? allPages[currentIndex + 1] : null;

// Process downloads to build file tree structure
const codeFiles = downloads.filter((d: any) => d.title?.startsWith('root/code/'));

// Build hierarchical tree structure from flat file list
interface TreeNode {
  name: string;
  path: string;
  type: 'file' | 'folder';
  url?: string;
  size?: string;
  id?: string;  // CID for files
  children?: TreeNode[];
}

function buildFileTree(files: any[]): TreeNode[] {
  const root: TreeNode[] = [];
  const folderMap = new Map<string, TreeNode>();

  files.forEach((file: any) => {
    // Remove 'root/code/' prefix
    const relativePath = file.title.replace('root/code/', '');
    const parts = relativePath.split('/');
    const fileName = parts[parts.length - 1];

    // Build folder structure
    let currentPath = '';
    for (let i = 0; i < parts.length - 1; i++) {
      const folderName = parts[i];
      const parentPath = currentPath;
      currentPath = currentPath ? `${currentPath}/${folderName}` : folderName;

      if (!folderMap.has(currentPath)) {
        const folderNode: TreeNode = {
          name: folderName,
          path: currentPath,
          type: 'folder',
          children: []
        };
        folderMap.set(currentPath, folderNode);

        // Add to parent or root
        if (parentPath) {
          const parent = folderMap.get(parentPath);
          parent?.children?.push(folderNode);
        } else {
          root.push(folderNode);
        }
      }
    }

    // Add file
    const fileNode: TreeNode = {
      name: fileName,
      path: relativePath,
      type: 'file',
      url: file.url,
      size: file.extra?.size_bytes ? formatBytes(file.extra.size_bytes) : undefined,
      id: file.id  // CID from download object
    };

    if (parts.length === 1) {
      root.push(fileNode);
    } else {
      const parentPath = parts.slice(0, -1).join('/');
      const parent = folderMap.get(parentPath);
      parent?.children?.push(fileNode);
    }
  });

  return root;
}

function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${Math.round(bytes / Math.pow(k, i) * 10) / 10} ${sizes[i]}`;
}

const fileTree = buildFileTree(codeFiles);

// Determine medical imaging file extensions
const meshExtensions = ['.stl', '.ply', '.mz3', '.off', '.obj', '.fsa', '.fsb', '.byu', '.x3d', '.gii', '.vtp'];
const volumeExtensions = ['.nii', '.nii.gz', '.dcm', '.nrrd', '.mha', '.mhd', '.vtk', '.vti', '.aim', '.isq', '.gipl', '.gipl.gz', '.hdf5', '.iwi', '.iwi.cbor', '.iwi.cbor.zst', '.lsm', '.mnc', '.mnc.gz', '.mgh', '.mgz', '.mgh.gz', '.mrc', '.pic', '.fdf', '.swc', '.fz', '.gqi', '.qsdr', '.mih', '.mif', '.v', '.v16', '.vmr', '.head', '.tract', '.tt', '.trx', '.trk', '.tck', '.annot'];
const medicalImageExtensions = [...volumeExtensions, ...meshExtensions];
const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.tif'];
const codeExtensions = ['.py', '.cxx', '.cpp', '.h', '.hxx', '.txx', '.hpp', '.c', '.js', '.ts', '.java', '.cs', '.md', '.txt', '.cmake', '.json', '.xml', '.yaml', '.yml'];

function getFileExtension(filename: string): string {
  // Check for complex multi-dot extensions first
  const complexExtensions = ['.nii.gz', '.gipl.gz', '.mnc.gz', '.mgh.gz', '.iwi.cbor', '.iwi.cbor.zst'];
  for (const ext of complexExtensions) {
    if (filename.endsWith(ext)) return ext;
  }

  // Fall back to simple extension matching
  const match = filename.match(/\.([^.]+)$/);
  return match ? `.${match[1]}` : '';
}

function isMedicalImage(filename: string): boolean {
  const ext = getFileExtension(filename);
  return medicalImageExtensions.some(e => filename.endsWith(e));
}

function isMeshFile(filename: string): boolean {
  const ext = getFileExtension(filename);
  return meshExtensions.some(e => filename.endsWith(e));
}

function isVolumeFile(filename: string): boolean {
  const ext = getFileExtension(filename);
  return volumeExtensions.some(e => filename.endsWith(e));
}

function isImage(filename: string): boolean {
  const ext = getFileExtension(filename);
  return imageExtensions.includes(ext.toLowerCase());
}

function isCodeFile(filename: string): boolean {
  const ext = getFileExtension(filename);
  return codeExtensions.includes(ext.toLowerCase()) || !isMedicalImage(filename) && !isImage(filename);
}

// Find default file to display
let defaultFile: TreeNode | null = null;

function findDefaultFile(nodes: TreeNode[]): TreeNode | null {
  // First priority: volume/medical image files
  for (const node of nodes) {
    if (node.type === 'file') {
      if (isVolumeFile(node.name)) return node;
    }
    if (node.children) {
      const found = findDefaultFile(node.children);
      if (found && isVolumeFile(found.name)) return found;
    }
  }

  // Second priority: mesh files
  for (const node of nodes) {
    if (node.type === 'file') {
      if (isMeshFile(node.name)) return node;
    }
    if (node.children) {
      const found = findDefaultFile(node.children);
      if (found && isMeshFile(found.name)) return found;
    }
  }

  // Third priority: regular images
  for (const node of nodes) {
    if (node.type === 'file') {
      if (isImage(node.name)) return node;
    }
    if (node.children) {
      const found = findDefaultFile(node.children);
      if (found && isImage(found.name)) return found;
    }
  }

  // Otherwise, first code file
  for (const node of nodes) {
    if (node.type === 'file') return node;
    if (node.children) {
      const found = findDefaultFile(node.children);
      if (found) return found;
    }
  }

  return null;
}

defaultFile = findDefaultFile(fileTree);

// Function to replace email addresses with icon links
function replaceEmailsWithIcons(html: string): string {
  // Regex to find email addresses (both in links and plain text)
  const emailRegex = /(<a[^>]*href=["']mailto:([^"']+)["'][^>]*>)([^<]+)(<\/a>)|([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g;

  return html.replace(emailRegex, (match, linkStart, linkEmail, linkText, linkEnd, plainEmail) => {
    if (plainEmail) {
      // Replace plain email with icon link
      return `<a href="mailto:${plainEmail}" title="Email" style="color: var(--wa-color-text-quiet); transition: color 0.2s; margin-left: var(--wa-space-2xs); text-decoration: none;" onmouseover="this.style.color='var(--wa-color-primary-600)'" onmouseout="this.style.color='var(--wa-color-text-quiet)'"><wa-icon library="scienceicons" name="email" style="font-size: 0.875rem; vertical-align: middle;"></wa-icon></a>`;
    } else if (linkStart && linkEmail) {
      // Replace email link with icon link
      return `<a href="mailto:${linkEmail}" title="Email" style="color: var(--wa-color-text-quiet); transition: color 0.2s; margin-left: var(--wa-space-2xs); text-decoration: none;" onmouseover="this.style.color='var(--wa-color-primary-600)'" onmouseout="this.style.color='var(--wa-color-text-quiet)'"><wa-icon library="scienceicons" name="email" style="font-size: 0.875rem; vertical-align: middle;"></wa-icon></a>`;
    }
    return match;
  });
}

// Check if reviews.md exists in downloads
const reviewsFile = downloads.find((d: any) => d.title === 'root/reviews.md');
let reviewsContent = '';

console.log('Checking for reviews file...', reviewsFile);
console.log('All downloads:', downloads.map((d: any) => d.title));

if (reviewsFile?.url) {
  try {
    console.log('Fetching reviews from:', reviewsFile.url);
    const response = await fetch(reviewsFile.url);
    const reviewsMarkdown = await response.text();
    console.log('Reviews markdown length:', reviewsMarkdown.length);
    let renderedContent = await mystParseAndRender(reviewsMarkdown);
    // Replace emails with icon links
    reviewsContent = replaceEmailsWithIcons(renderedContent);
    console.log('Rendered reviews content length:', reviewsContent.length);
  } catch (error) {
    console.error('Error fetching or parsing reviews:', error);
  }
}

// Helper function to get icon name based on file extension
function getFileIcon(filename: string): string {
  const ext = getFileExtension(filename).toLowerCase();

  // Medical imaging formats
  if (medicalImageExtensions.some(e => filename.endsWith(e))) return 'file-zipper';

  // Images
  if (imageExtensions.includes(ext)) return 'file-image';

  // Code files
  const codeIconMap: Record<string, string> = {
    '.py': 'file-code',
    '.cpp': 'file-code',
    '.cxx': 'file-code',
    '.h': 'file-code',
    '.hxx': 'file-code',
    '.txx': 'file-code',
    '.hpp': 'file-code',
    '.c': 'file-code',
    '.js': 'file-code',
    '.ts': 'file-code',
    '.java': 'file-code',
    '.cs': 'file-code',
    '.cmake': 'file-code',
    '.json': 'file-code',
    '.xml': 'file-code',
    '.yaml': 'file-code',
    '.yml': 'file-code',
    '.md': 'file-lines',
    '.txt': 'file-lines',
  };

  return codeIconMap[ext] || 'file';
}
---

{/* Store tree rendering function in template section */}

<!-- Recursive component for rendering file tree nodes -->
{fileTree.length > 0 && (
  <script is:inline define:vars={{ fileTree, defaultFile }}>
    // Store file tree data globally for access in event handlers
    window.fileTreeData = fileTree;
    window.defaultFileData = defaultFile;
  </script>
)}

{/* Helper component to render tree nodes recursively */}

<!-- Actual file tree will be rendered in the template below -->

<BasePage
  title={title}
  description={abstract}
  theme="default"
  colorScheme="auto"
  mobileBreakpoint="920px"
>
  <Header slot="header" />

  <!-- Navigation with search -->
  <div slot="navigation-header" class="nav-header">
    <div class="nav-logo">
      <a href="/">
        <img
          src="/assets/logo-insight-journal-square-dark.png"
          alt="Insight Journal logo"
          class="project-logo theme-aware-logo"
        />
      </a>
    </div>

    <!-- Previous/Next Navigation -->
    <div class="page-navigation">
      {prevPage && (
        <a href={generatePageUrl(prevPage.id, foldersOption, baseDir)} class="nav-page-link prev-page">
          <div class="nav-page-thumbnail">
            {prevPage.data.frontmatter?.thumbnail && prevPage.data.slug ? (
              <img
                src={`/thumbnails/${prevPage.data.slug}.jpg`}
                alt={prevPage.data.frontmatter.title || 'Previous page'}
              />
            ) : (
              <div class="nav-page-placeholder">
                <wa-icon name="arrow-left"></wa-icon>
              </div>
            )}
          </div>
          <div class="nav-page-info">
            <span class="nav-page-label">Previous</span>
            <span class="nav-page-title">{prevPage.data.frontmatter?.title || prevPage.id}</span>
          </div>
        </a>
      )}

      {nextPage && (
        <a href={generatePageUrl(nextPage.id, foldersOption, baseDir)} class="nav-page-link next-page">
          <div class="nav-page-thumbnail">
            {nextPage.data.frontmatter?.thumbnail && nextPage.data.slug ? (
              <img
                src={`/thumbnails/${nextPage.data.slug}.jpg`}
                alt={nextPage.data.frontmatter.title || 'Next page'}
              />
            ) : (
              <div class="nav-page-placeholder">
                <wa-icon name="arrow-right"></wa-icon>
              </div>
            )}
          </div>
          <div class="nav-page-info">
            <span class="nav-page-label">Next</span>
            <span class="nav-page-title">{nextPage.data.frontmatter?.title || nextPage.id}</span>
          </div>
        </a>
      )}
    </div>
  </div>

  <!-- Main content -->
  <div class="publication-content">
    <!-- Frontmatter Block with fancy background -->
    <div class="frontmatter-container">
      <div class="frontmatter-background">
        <div class="frontmatter-overlay">
          <!-- Publication metadata header -->
          <div class="publication-metadata">
            <div class="metadata-left">
              <span class="article-type">Open Science Article</span>
              {frontmatter?.date_submitted && (
                <span class="submitted-date">
                  Submitted: {new Date(frontmatter.date_submitted).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                  })}
                </span>
              )}
              {page?.doi && (
                <a
                  href={`https://doi.org/${page.doi}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  class="doi-link"
                >
                  {`https://doi.org/${page.doi}`}
                </a>
              )}
            </div>
            <div class="metadata-right">
              {frontmatter?.github && typeof frontmatter.github === 'string' && (
                <a
                  href={frontmatter.github}
                  target="_blank"
                  rel="noopener noreferrer"
                  class="github-link"
                  title="View on GitHub"
                >
                  <wa-icon library="scienceicons" name="github" class="github-icon"></wa-icon>
                </a>
              )}
              <wa-icon library="scienceicons" name="open-access" class="openaccess-icon"></wa-icon>
            </div>
          </div>

          <header>
            <h1 class="publication-title">{title}</h1>
          </header>
          <Authors authors={frontmatter?.authors} />
        </div>
      </div>
    </div>

    <!-- Tab Group for content sections -->
    <wa-tab-group class="content-tabs">
      <!-- Abstract Tab -->
      <wa-tab slot="nav" panel="abstract">Abstract</wa-tab>
      <wa-tab-panel name="abstract">
        <div class="tab-content">
          {frontmatter?.thumbnail && publicationId && (
            <div class="thumbnail-container">
              <img
                src={`/thumbnails/${publicationId}.jpg`}
                alt={title}
                height="350"
                class="abstract-thumbnail"
              />
            </div>
          )}
          <h2>Abstract</h2>
          <p>{abstract}</p>
          {frontmatter?.keywords && (
            <div class="keywords">
              <h3>Keywords</h3>
              <div class="keyword-tags">
                {frontmatter.keywords.map((keyword: string) => (
                  <wa-badge variant="neutral">{keyword}</wa-badge>
                ))}
              </div>
            </div>
          )}
        </div>
      </wa-tab-panel>

      <!-- Manuscript Tab (only show if PDF exists) -->
      {hasPdfFile && <wa-tab slot="nav" panel="manuscript">Manuscript</wa-tab>}
      {hasPdfFile && (
      <wa-tab-panel name="manuscript">
        <div class="tab-content">
          <div class="pdf-viewer">
            <iframe
              src={`/pdfs/${page.slug}.pdf`}
              width="100%"
              height="1200px"
              style="border: none;"
              title="Article PDF"
            ></iframe>
          </div>
        </div>
      </wa-tab-panel>
      )}

      <!-- Source Code and Data Tab -->
      <wa-tab slot="nav" panel="files">Source Code and Data</wa-tab>
      <wa-tab-panel name="files">
        <div class="tab-content">
          <div class="source-code-header">
            <h2>Source Code and Data</h2>
            {codeFiles.length > 0 && (
              <button id="download-all-button" class="download-all-button" title="Download all files as ZIP">
                <wa-icon name="download"></wa-icon>
                <span></span>
              </button>
            )}
          </div>

          {codeFiles.length > 0 ? (
            <div class="file-browser-grid">
              <!-- Left side: File Tree -->
              <div class="file-tree-container">
                <wa-tree class="file-tree" id="file-tree" selection="single">
                  {fileTree.map((node) => {
                    // Recursive rendering function defined inline
                    const renderNode = (n: TreeNode): any => {
                      if (n.type === 'folder') {
                        return (
                          <wa-tree-item data-path={n.path} data-type="folder">
                            <wa-icon name="folder" variant="regular"></wa-icon>
                            {n.name}
                            {n.children?.map((child) => renderNode(child))}
                          </wa-tree-item>
                        );
                      } else {
                        return (
                          <wa-tree-item
                            data-path={n.path}
                            data-type={n.type}
                            data-url={n.url}
                            data-cid={n.id}
                            class={n.url === defaultFile?.url ? 'selected-file' : ''}
                          >
                            <wa-icon name={getFileIcon(n.name)} variant="regular"></wa-icon>
                            {n.name}
                            {n.size && (
                              <span slot="end" class="file-actions">
                                <span class="file-size">{n.size}</span>
                                <wa-icon
                                  name="copy"
                                  variant="regular"
                                  class="action-icon copy-cid-icon"
                                  data-cid={n.id}
                                  title="Copy CID"
                                ></wa-icon>
                                <wa-icon
                                  name="download"
                                  class="action-icon download-icon"
                                  data-url={n.url}
                                  title="Download file"
                                ></wa-icon>
                              </span>
                            )}
                          </wa-tree-item>
                        );
                      }
                    };
                    return renderNode(node);
                  })}
                </wa-tree>
              </div>

              <!-- Right side: File Preview -->
              <div class="file-preview-container">
                <!-- Code viewer -->
                <div id="code-viewer" class="viewer-panel" style="display: none;">
                  <div class="viewer-header">
                    <h3 id="code-viewer-title">File</h3>
                  </div>
                  <div class="code-content">
                    <pre><code id="code-viewer-content"></code></pre>
                  </div>
                </div>

                <!-- Medical/3D Image viewer -->
                <div id="image-viewer" class="viewer-panel" style="display: none;">
                  <div class="viewer-header">
                    <h3 id="image-viewer-title">Image</h3>
                  </div>
                  <canvas id="niivue-canvas"></canvas>
                </div>

                <!-- 2D Image viewer -->
                <div id="image2d-viewer" class="viewer-panel" style="display: none;">
                  <div class="viewer-header">
                    <h3 id="image2d-viewer-title">Image</h3>
                  </div>
                  <img id="image2d-content" alt="Preview" />
                </div>

                <!-- Initial message -->
                <div id="no-file-selected" class="viewer-panel">
                  <div class="no-file-message">
                    <wa-icon name="file-code" style="font-size: 4rem; opacity: 0.3;"></wa-icon>
                    <p>Select a file to preview</p>
                  </div>
                </div>
              </div>
            </div>
          ) : (
            <p>No source code files available for this publication.</p>
          )}
        </div>
      </wa-tab-panel>

      <!-- Reviews Tab (only show if reviews exist) -->
      {reviewsContent && <wa-tab slot="nav" panel="reviews">Reviews</wa-tab>}
      {reviewsContent && (
        <wa-tab-panel name="reviews">
          <div class="tab-content">
            <div class="reviews-content" set:html={reviewsContent} />
          </div>
        </wa-tab-panel>
      )}
    </wa-tab-group>

    <!-- Mobile Previous/Next Navigation (shown below tabs on mobile) -->
    <div class="page-navigation-mobile">
      {prevPage && (
        <a href={generatePageUrl(prevPage.id, foldersOption, baseDir)} class="nav-page-link prev-page">
          <div class="nav-page-thumbnail">
            {prevPage.data.frontmatter?.thumbnail && prevPage.data.slug ? (
              <img
                src={`/thumbnails/${prevPage.data.slug}.jpg`}
                alt={prevPage.data.frontmatter.title || 'Previous page'}
              />
            ) : (
              <div class="nav-page-placeholder">
                <wa-icon name="arrow-left"></wa-icon>
              </div>
            )}
          </div>
          <div class="nav-page-info">
            <span class="nav-page-label">Previous</span>
            <span class="nav-page-title">{prevPage.data.frontmatter?.title || prevPage.id}</span>
          </div>
        </a>
      )}

      {nextPage && (
        <a href={generatePageUrl(nextPage.id, foldersOption, baseDir)} class="nav-page-link next-page">
          <div class="nav-page-thumbnail">
            {nextPage.data.frontmatter?.thumbnail && nextPage.data.slug ? (
              <img
                src={`/thumbnails/${nextPage.data.slug}.jpg`}
                alt={nextPage.data.frontmatter.title || 'Next page'}
              />
            ) : (
              <div class="nav-page-placeholder">
                <wa-icon name="arrow-right"></wa-icon>
              </div>
            )}
          </div>
          <div class="nav-page-info">
            <span class="nav-page-label">Next</span>
            <span class="nav-page-title">{nextPage.data.frontmatter?.title || nextPage.id}</span>
          </div>
        </a>
      )}
    </div>
  </div>

  <!-- Footer -->
  <Footer slot="footer" />
</BasePage>

<script>
  // Import Web Awesome components
  import '@awesome.me/webawesome/dist/components/tab-group/tab-group.js';
  import '@awesome.me/webawesome/dist/components/tab/tab.js';
  import '@awesome.me/webawesome/dist/components/tab-panel/tab-panel.js';
  import '@awesome.me/webawesome/dist/components/tree/tree.js';
  import '@awesome.me/webawesome/dist/components/tree-item/tree-item.js';
  import '@awesome.me/webawesome/dist/components/badge/badge.js';

  import { Niivue, SLICE_TYPE, MULTIPLANAR_TYPE, SHOW_RENDER } from "@niivue/niivue";
  import pLimit from 'p-limit';
  import { imageExtensions, createImageLoader } from '@niivue/itkwasm-loader';
  import { dicomLoader } from '@niivue/dicom-loader';
  import { downloadZip } from 'client-zip';

  // Import highlight.js core and individual languages
  import hljs from 'highlight.js/lib/core';
  import python from 'highlight.js/lib/languages/python';
  import cpp from 'highlight.js/lib/languages/cpp';
  import c from 'highlight.js/lib/languages/c';
  import javascript from 'highlight.js/lib/languages/javascript';
  import typescript from 'highlight.js/lib/languages/typescript';
  import java from 'highlight.js/lib/languages/java';
  import csharp from 'highlight.js/lib/languages/csharp';
  import markdown from 'highlight.js/lib/languages/markdown';
  import cmake from 'highlight.js/lib/languages/cmake';
  import json from 'highlight.js/lib/languages/json';
  import xml from 'highlight.js/lib/languages/xml';
  import yaml from 'highlight.js/lib/languages/yaml';
  import plaintext from 'highlight.js/lib/languages/plaintext';

  // Register languages
  hljs.registerLanguage('python', python);
  hljs.registerLanguage('cpp', cpp);
  hljs.registerLanguage('c', c);
  hljs.registerLanguage('javascript', javascript);
  hljs.registerLanguage('typescript', typescript);
  hljs.registerLanguage('java', java);
  hljs.registerLanguage('csharp', csharp);
  hljs.registerLanguage('markdown', markdown);
  hljs.registerLanguage('cmake', cmake);
  hljs.registerLanguage('json', json);
  hljs.registerLanguage('xml', xml);
  hljs.registerLanguage('yaml', yaml);
  hljs.registerLanguage('plaintext', plaintext);

  // Theme-aware logo switching functionality
  document.addEventListener('DOMContentLoaded', async () => {
    // Theme-aware logo switching
    const updateLogoForTheme = () => {
      const isDark = document.documentElement.classList.contains('wa-dark');
      const logoElement = document.querySelector('.theme-aware-logo') as HTMLImageElement;

      if (logoElement) {
        if (isDark) {
          logoElement.src = '/assets/logo-insight-journal-square-dark.png';
        } else {
          logoElement.src = '/assets/logo-insight-journal-square-light.png';
        }
      }
    };

    updateLogoForTheme();

    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          updateLogoForTheme();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });

    // File browser functionality
    let nv: Niivue | null = null;
    let currentViewerType: 'code' | 'image3d' | 'image2d' | 'none' = 'none';

    // Initialize NiiVue
    const initializeNiiVue = async () => {
      if (!nv) {
        const isDark = document.documentElement.classList.contains('wa-dark');
        const defaults = {
          backColor: isDark ? [16.0/255.0, 18.0/255.0, 25.0/255.0, 1.0] : [1, 1, 1, 1],
          logLevel: 'info' as const,
          showLegend: true,
          showColorbarBorder: false,
          isColorBar: true,
          isOrientCube: true,
          isOrientationTextVisible: false,
          sliceType: SLICE_TYPE.MULTIPLANAR,
          multiplanarRender: MULTIPLANAR_TYPE.GRID,
          multiplanarShowRender: SHOW_RENDER.ALWAYS,
          heroImageFraction: 0.6,
        };
        nv = new Niivue(defaults);
        const canvas = document.getElementById("niivue-canvas") as HTMLCanvasElement;
        if (canvas) {
          await nv.attachToCanvas(canvas);

          // Register ITK-Wasm loaders for each supported image extension
          for (const ext of imageExtensions) {
            nv.useLoader(createImageLoader(ext), ext, 'nii');
          }

          nv.useDicomLoader({ loader: dicomLoader });
        }
      }
    };

    // Show specific viewer
    const showViewer = (type: 'code' | 'image3d' | 'image2d' | 'none') => {
      document.getElementById('code-viewer')!.style.display = type === 'code' ? 'block' : 'none';
      document.getElementById('image-viewer')!.style.display = type === 'image3d' ? 'block' : 'none';
      document.getElementById('image2d-viewer')!.style.display = type === 'image2d' ? 'block' : 'none';
      document.getElementById('no-file-selected')!.style.display = type === 'none' ? 'flex' : 'none';
      currentViewerType = type;
    };

    // Helper function to find companion file for MHD/RAW pairs
    const findCompanionFile = (filename: string, fileTreeData: any[]): string | null => {
      const baseNameMatch = filename.match(/^(.+)\.(mhd|raw)$/i);
      if (!baseNameMatch) return null;

      const baseName = baseNameMatch[1];
      const currentExt = baseNameMatch[2].toLowerCase();
      const companionExt = currentExt === 'mhd' ? 'raw' : 'mhd';
      const companionFilename = `${baseName}.${companionExt}`;

      // Search recursively in the file tree
      const searchTree = (nodes: any[]): string | null => {
        for (const node of nodes) {
          if (node.type === 'file' && node.name.toLowerCase() === companionFilename.toLowerCase()) {
            return node.url;
          }
          if (node.children) {
            const found = searchTree(node.children);
            if (found) return found;
          }
        }
        return null;
      };

      return searchTree(fileTreeData);
    };

    // Helper function to combine MHD and RAW files into MHA format
    const combineMhdRawToMha = async (mhdUrl: string, rawUrl: string, baseName: string): Promise<{ buffer: ArrayBuffer, name: string }> => {
      // Fetch both files
      const [mhdResponse, rawResponse] = await Promise.all([
        fetch(mhdUrl),
        fetch(rawUrl)
      ]);

      // Get MHD text and RAW binary data
      const mhdText = await mhdResponse.text();
      const rawBuffer = await rawResponse.arrayBuffer();

      // Edit MHD header to replace ElementDataFile line
      const lines = mhdText.split('\n');
      const editedLines = lines.map(line => {
        if (line.trim().startsWith('ElementDataFile')) {
          return 'ElementDataFile = LOCAL';
        }
        return line;
      });
      const editedMhd = editedLines.join('\n');

      // Convert edited MHD text to ArrayBuffer
      const encoder = new TextEncoder();
      const mhdBuffer = encoder.encode(editedMhd);

      // Concatenate MHD header and RAW data
      const combinedBuffer = new ArrayBuffer(mhdBuffer.byteLength + rawBuffer.byteLength);
      const combinedView = new Uint8Array(combinedBuffer);
      combinedView.set(new Uint8Array(mhdBuffer), 0);
      combinedView.set(new Uint8Array(rawBuffer), mhdBuffer.byteLength);

      // Create MHA filename
      const mhaName = `${baseName}.mha`;

      console.log(`Combined MHD/RAW into MHA: ${mhaName} (${combinedBuffer.byteLength} bytes)`);

      return { buffer: combinedBuffer, name: mhaName };
    };

    // Helper function to detect if VTK file is a volume or mesh
    const isVtkVolume = async (url: string): Promise<boolean> => {
      try {
        const response = await fetch(url, {
          headers: {
            'Range': 'bytes=0-383'
          }
        });
        const buffer = await response.arrayBuffer();
        const text = new TextDecoder('utf-8').decode(buffer);
        return text.includes('STRUCTURED_POINTS') || text.includes('STRUCTURED_GRID') || text.includes('RECTILINEAR_GRID') || text.includes('IMAGE_DATA');
      } catch (error) {
        console.error('Error checking VTK file type:', error);
        // Default to mesh if we can't determine
        return false;
      }
    };

    // Load and display a file
    const loadFile = async (url: string, filename: string) => {
      const ext = filename.toLowerCase();

      // Define mesh extensions (note: .vtk can be either mesh or volume, so we'll check it)
      const meshExts = ['.stl', '.ply', '.mz3', '.off', '.obj', '.fsa', '.fsb', '.byu', '.x3d', '.gii', '.vtp'];
      let isMesh = meshExts.some(e => ext.endsWith(e));

      // Define volume/image extensions
      const volumeExts = ['.nii', '.nii.gz', '.dcm', '.nrrd', '.mha', '.mhd', '.vti', '.aim', '.isq', '.gipl', '.gipl.gz', '.hdf5', '.iwi', '.iwi.cbor', '.iwi.cbor.zst', '.lsm', '.mnc', '.mnc.gz', '.mgh', '.mgz', '.mgh.gz', '.mrc', '.pic', '.fdf', '.swc', '.fz', '.gqi', '.qsdr', '.mih', '.mif', '.v', '.v16', '.vmr', '.head', '.tract', '.tt', '.trx', '.trk', '.tck', '.annot'];
      let isVolume = volumeExts.some(e => ext.endsWith(e));

      // Special handling for .vtk files - can be either volume or mesh
      if (ext.endsWith('.vtk')) {
        const isVtkVol = await isVtkVolume(url);
        if (isVtkVol) {
          isVolume = true;
          isMesh = false;
        } else {
          isMesh = true;
          isVolume = false;
        }
      }

      const isMedical = isMesh || isVolume;

      // Check if it's a regular image
      const imageExts = ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.tif'];
      const isImage = imageExts.some(e => ext.endsWith(e));

      if (isMedical) {
        // Load with NiiVue
        await initializeNiiVue();
        showViewer('image3d');
        document.getElementById('image-viewer-title')!.textContent = filename;

        try {
          if (nv) {
            // Clear existing volumes/meshes
            if (nv.volumes.length > 0) {
              nv.removeVolumeByIndex(0);
            }
            while (nv.meshes.length > 0) {
              nv.removeMesh(nv.meshes[0]);
            }

            // Load based on file type
            if (isMesh) {
              // Load mesh files
              await nv.loadMeshes([{ url, name: filename }]);
            } else if (ext.endsWith('.dcm')) {
              // DICOM files need special handling
              await nv.loadDicoms([{ url, name: filename }]);
            } else if (ext.endsWith('.mhd') || ext.endsWith('.raw')) {
              // Check for MHD/RAW companion files and combine them
              const companionUrl = findCompanionFile(filename, (window as any).fileTreeData);
              if (companionUrl) {
                // Determine which is MHD and which is RAW
                const isMhd = ext.endsWith('.mhd');
                const mhdUrl = isMhd ? url : companionUrl;
                const rawUrl = isMhd ? companionUrl : url;
                const baseName = filename.replace(/\.(mhd|raw)$/i, '');

                // Combine into MHA format
                const { buffer, name: mhaName } = await combineMhdRawToMha(mhdUrl, rawUrl, baseName);

                // Create Blob and object URL from the combined buffer
                const blob = new Blob([buffer], { type: 'application/octet-stream' });
                const objectUrl = URL.createObjectURL(blob);

                // Load the combined MHA buffer
                await nv.loadVolumes([{ url: objectUrl, name: mhaName }]);

                // Clean up object URL after loading
                URL.revokeObjectURL(objectUrl);
              } else {
                // No companion found, try loading as-is
                await nv.loadVolumes([{ url, name: filename }]);
              }
            } else {
              // Regular volume file
              await nv.loadVolumes([{ url, name: filename }]);
            }

            nv.resizeListener();
            nv.drawScene();
          }
        } catch (error) {
          console.error('Error loading medical image:', error);
        }
      } else if (isImage) {
        // Load as regular image
        showViewer('image2d');
        document.getElementById('image2d-viewer-title')!.textContent = filename;
        const img = document.getElementById('image2d-content') as HTMLImageElement;
        img.src = url;
      } else {
        // Load as code/text
        showViewer('code');
        document.getElementById('code-viewer-title')!.textContent = filename;

        try {
          const response = await fetch(url);
          const text = await response.text();
          const codeElement = document.getElementById('code-viewer-content')!;

          // Determine language from file extension
          const ext = filename.toLowerCase();
          let language = 'plaintext';

          if (ext.endsWith('.py')) language = 'python';
          else if (ext.endsWith('.cpp') || ext.endsWith('.cxx') || ext.endsWith('.cc')) language = 'cpp';
          else if (ext.endsWith('.c')) language = 'c';
          else if (ext.endsWith('.h') || ext.endsWith('.hpp') || ext.endsWith('.hxx') || ext.endsWith('.txx')) language = 'cpp';
          else if (ext.endsWith('.js')) language = 'javascript';
          else if (ext.endsWith('.ts')) language = 'typescript';
          else if (ext.endsWith('.java')) language = 'java';
          else if (ext.endsWith('.cs')) language = 'csharp';
          else if (ext.endsWith('.md')) language = 'markdown';
          else if (ext.endsWith('.cmake') || filename.toLowerCase() === 'cmakelists.txt') language = 'cmake';
          else if (ext.endsWith('.json')) language = 'json';
          else if (ext.endsWith('.xml')) language = 'xml';
          else if (ext.endsWith('.yaml') || ext.endsWith('.yml')) language = 'yaml';

          // Apply syntax highlighting
          const highlighted = hljs.highlight(text, { language }).value;
          codeElement.innerHTML = highlighted;
        } catch (error) {
          console.error('Error loading file:', error);
          document.getElementById('code-viewer-content')!.textContent = 'Error loading file';
        }
      }
    };

    // Escape HTML for code display
    const escapeHtml = (text: string) => {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    };

    // Handle file tree clicks
    const fileTree = document.getElementById('file-tree');
    if (fileTree) {
      fileTree.addEventListener('wa-selection-change', (event: any) => {
        const selectedItems = event.detail.selection;
        if (selectedItems.length > 0) {
          const item = selectedItems[0];
          const url = item.dataset.url;
          const type = item.dataset.type;
          const path = item.dataset.path;

          if (type === 'file' && url) {
            const filename = path.split('/').pop() || 'file';
            loadFile(url, filename);
          }
        }
      });

      // Handle tree item clicks (expansion and action icons)
      fileTree.addEventListener('click', async (event: any) => {
        let target = event.target as HTMLElement;

        // Find the closest action icon (in case we clicked on SVG or other child)
        const copyIcon = target.closest('.copy-cid-icon') as HTMLElement;
        const downloadIcon = target.closest('.download-icon') as HTMLElement;

        if (copyIcon) {
          event.stopPropagation();
          event.preventDefault();
          // Find the parent tree item to get the URL
          const treeItem = copyIcon.closest('wa-tree-item') as HTMLElement;
          if (treeItem) {
            const url = treeItem.getAttribute('data-url');
            if (url) {
              // Extract CID from IPFS URL (format: https://ipfs.io/ipfs/CID)
              const cidMatch = url.match(/\/ipfs\/([^\/]+)/);
              const cid = cidMatch ? cidMatch[1] : url;

              try {
                await navigator.clipboard.writeText(cid);
                // Visual feedback
                const originalColor = copyIcon.style.color;
                copyIcon.style.color = 'var(--wa-color-success-600)';
                setTimeout(() => {
                  copyIcon.style.color = originalColor;
                }, 1000);
                console.log('Copied CID to clipboard:', cid);
              } catch (err) {
                console.error('Failed to copy CID:', err);
              }
            }
          }
        } else if (downloadIcon) {
          // Find the parent tree item to get URL and filename
          const treeItem = downloadIcon.closest('wa-tree-item') as HTMLElement;
          if (treeItem) {
            const url = treeItem.getAttribute('data-url');
            const path = treeItem.getAttribute('data-path');
            const filename = path ? path.split('/').pop() : 'download';

            if (url && filename) {
              try {
                // Fetch the file and trigger download with correct filename
                const response = await fetch(url);
                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // Clean up the blob URL
                setTimeout(() => URL.revokeObjectURL(blobUrl), 100);

                console.log('Downloaded file:', filename);
              } catch (err) {
                console.error('Failed to download file:', err);
              }
            }
          }
          event.stopPropagation();
          event.preventDefault();
        }
        // Note: We don't need custom folder expansion logic here.
        // WebAwesome tree items handle expansion automatically when clicking the expand arrow.
        // File selection is handled by the 'wa-selection-change' event listener above.
      });
    }

    // Handle download all files as ZIP
    const downloadAllButton = document.getElementById('download-all-button') as HTMLButtonElement;
    if (downloadAllButton) {
      downloadAllButton.addEventListener('click', async () => {
        // Disable button and show loading state
        downloadAllButton.disabled = true;
        const originalText = downloadAllButton.querySelector('span')!.textContent;
        downloadAllButton.querySelector('span')!.textContent = 'Preparing...';

        try {
          // Get all file tree items
          const allTreeItems = document.querySelectorAll('wa-tree-item[data-type="file"]');

          // Create a limit function with concurrency of 6
          const limit = pLimit(6);

          // Create an async generator that yields file inputs
          async function* generateFiles() {
            for (const item of allTreeItems) {
              const url = item.getAttribute('data-url');
              const path = item.getAttribute('data-path');

              if (url && path) {
                const filename = path;

                // Use limit to control concurrent fetches
                const fileData = await limit(async () => {
                  try {
                    // Fetch the file
                    const response = await fetch(url);

                    return {
                      name: filename,
                      input: response.body!,
                      lastModified: new Date()
                    };
                  } catch (err) {
                    console.error(`Failed to fetch ${filename}:`, err);
                    return null;
                  }
                });

                // Only yield if fetch was successful
                if (fileData) {
                  yield fileData;
                }
              }
            }
          }

          // Create the ZIP and download it
          const zipBlob = await downloadZip(generateFiles()).blob();
          const zipUrl = URL.createObjectURL(zipBlob);

          // Get publication title for filename
          const publicationTitle = document.querySelector('h1')?.textContent?.trim() || 'publication';
          const safeTitle = publicationTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase();

          // Trigger download
          const a = document.createElement('a');
          a.href = zipUrl;
          a.download = `${safeTitle}_source_code_and_data.zip`;
          a.style.display = 'none';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);

          // Clean up
          setTimeout(() => URL.revokeObjectURL(zipUrl), 100);

          console.log('Downloaded all files as ZIP');
        } catch (err) {
          console.error('Failed to create ZIP:', err);
          alert('Failed to download files. Please try again.');
        } finally {
          // Re-enable button
          downloadAllButton.disabled = false;
          downloadAllButton.querySelector('span')!.textContent = originalText;
        }
      });
    }

    // Load default file when Source Code tab is activated
    const tabGroup = document.querySelector('wa-tab-group');
    if (tabGroup) {
      tabGroup.addEventListener('wa-tab-show', async (event: any) => {
        const tabName = event.detail.name;

        // Update URL when tab is clicked
        if (tabName && ['abstract', 'manuscript', 'files', 'reviews'].includes(tabName)) {
          history.pushState(null, '', `#${tabName}`);
        }

        if (tabName === 'files') {
          // Load default file if available
          const defaultFileEl = document.querySelector('.selected-file') as HTMLElement;
          if (defaultFileEl && currentViewerType === 'none') {
            const url = defaultFileEl.dataset.url;
            const path = defaultFileEl.dataset.path;
            if (url && path) {
              const filename = path.split('/').pop() || 'file';
              await loadFile(url, filename);
            }
          }
        }
      });
    }

    // Handle hash navigation for tabs
    const handleTabFromHash = () => {
      const hash = window.location.hash.substring(1); // Remove the # symbol
      if (hash && ['abstract', 'manuscript', 'files', 'reviews'].includes(hash)) {
        const tabGroup = document.querySelector('wa-tab-group');
        const targetTab = document.querySelector(`wa-tab[panel="${hash}"]`);

        if (tabGroup && targetTab) {
          // Activate the tab
          (targetTab as any).click();
        }
      }
    };

    // Handle initial hash on page load
    handleTabFromHash();

    // Handle hash changes
    window.addEventListener('hashchange', handleTabFromHash);
  });
</script>

<style>
  /* Navigation search */
  .ij-nav-search {
    padding: var(--wa-space-m);
    border-bottom: 1px solid var(--wa-color-surface-border);
  }

  .nav-search {
    width: 100%;
  }

  /* Publication content */
  .publication-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--wa-space-l);
  }

  /* Frontmatter container with fancy background */
  .frontmatter-container {
    margin-bottom: var(--wa-space-2xl);
  }

  .frontmatter-background {
    background: linear-gradient(135deg, #064f8d 0%, #2d3748 100%);
    border-radius: var(--wa-border-radius-m);
    padding: var(--wa-space-l);
    position: relative;
    overflow: hidden;
  }

  .frontmatter-background::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
    pointer-events: none;
  }

  .frontmatter-overlay {
    position: relative;
    z-index: 1;
    background: var(--wa-color-surface-default);
    backdrop-filter: blur(10px);
    border-radius: var(--wa-border-radius-l);
    padding: var(--wa-space-l);
    box-shadow: var(--wa-shadow-l);
  }

  .publication-title {
    font-size: var(--wa-font-size-xl);
    font-weight: var(--wa-font-weight-bold);
    color: var(--wa-color-text-loud);
    margin: 0 0 var(--wa-space-m) 0;
    line-height: var(--wa-line-height-condensed);
  }

  /* Publication metadata header */
  .publication-metadata {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--wa-space-l);
    padding-bottom: var(--wa-space-m);
    border-bottom: 1px solid var(--wa-color-surface-border);
    font-size: var(--wa-font-size-s);
  }

  .metadata-left {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: var(--wa-space-m);
    color: var(--wa-color-text-quiet);
  }

  .metadata-right {
    display: flex;
    align-items: center;
    gap: var(--wa-space-s);
  }

  .article-type {
    font-variant: small-caps;
    font-weight: var(--wa-font-weight-semibold);
    color: var(--wa-color-text-normal);
    letter-spacing: 0.05em;
  }

  .submitted-date {
    color: var(--wa-color-text-quiet);
  }

  .doi-link {
    color: var(--wa-color-primary-600);
    text-decoration: none;
    transition: color 0.2s;
  }

  .doi-link:hover {
    color: var(--wa-color-primary-700);
    text-decoration: underline;
  }

  .openaccess-icon {
    font-size: var(--wa-font-size-l);
    color: var(--wa-color-success-600);
  }

  .github-link {
    color: var(--wa-color-text-quiet);
    text-decoration: none;
    transition: color 0.2s;
    display: flex;
    align-items: center;
  }

  .github-link:hover {
    color: var(--wa-color-primary-600);
  }

  .github-icon {
    font-size: var(--wa-font-size-l);
  }

  /* Responsive adjustments for metadata */
  @media (max-width: 768px) {
    .publication-metadata {
      flex-direction: column;
      align-items: flex-start;
      gap: var(--wa-space-s);
    }

    .metadata-left {
      flex-direction: column;
      align-items: flex-start;
      gap: var(--wa-space-xs);
    }

    .metadata-right {
      align-self: flex-end;
    }
  }

  /* Content tabs */
  .content-tabs {
    --track-color: var(--wa-color-surface-border);
    --indicator-color: #ff6b35;
  }

  .tab-content {
    padding: var(--wa-space-l);
    background: var(--wa-color-surface-default);
    border-radius: var(--wa-border-radius-l);
    margin-top: var(--wa-space-m);
  }

  .tab-content h2 {
    color: var(--wa-color-text-normal);
    margin-bottom: var(--wa-space-m);
    font-size: var(--wa-font-size-2xl);
  }

  .tab-content h3 {
    color: var(--wa-color-text-normal);
    margin-bottom: var(--wa-space-s);
    font-size: var(--wa-font-size-xl);
  }

  /* Source Code Header with Download Button */
  .source-code-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: var(--wa-space-m);
  }

  .source-code-header h2 {
    margin-bottom: 0;
  }

  .download-all-button {
    display: inline-flex;
    align-items: center;
    gap: var(--wa-space-xs);
    padding: var(--wa-space-xs) var(--wa-space-m);
    background: var(--wa-color-primary-600);
    color: white;
    border: none;
    border-radius: var(--wa-border-radius-m);
    cursor: pointer;
    font-size: var(--wa-font-size-m);
    font-weight: var(--wa-font-weight-medium);
    transition: background-color 0.2s ease;
  }

  .download-all-button:hover {
    background: var(--wa-color-primary-700);
  }

  .download-all-button:active {
    background: var(--wa-color-primary-800);
  }

  .download-all-button:disabled {
    background: var(--wa-color-surface-border);
    color: var(--wa-color-text-quiet);
    cursor: not-allowed;
  }

  .download-all-button wa-icon {
    font-size: var(--wa-font-size-l);
  }

  /* Thumbnail in abstract */
  .thumbnail-container {
    margin-bottom: var(--wa-space-l);
    text-align: center;
  }

  .abstract-thumbnail {
    max-width: 100%;
    height: auto;
    border-radius: var(--wa-border-radius-m);
    box-shadow: var(--wa-shadow-m);
    border: 1px solid var(--wa-color-surface-border);
  }

  /* Keywords section */
  .keywords {
    margin-top: var(--wa-space-l);
  }

  .keyword-tags {
    display: flex;
    flex-wrap: wrap;
    gap: var(--wa-space-xs);
    margin-top: var(--wa-space-s);
  }

  /* PDF viewer */
  .pdf-viewer {
    border-radius: var(--wa-border-radius-m);
    overflow: hidden;
    box-shadow: var(--wa-shadow-m);
  }

  /* File tree section */
  .file-tree-section {
    margin-bottom: var(--wa-space-2xl);
  }

  .file-tree {
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    background: var(--wa-color-surface-lowered);
  }

  .file-size {
    font-size: var(--wa-font-size-xs);
    color: var(--wa-color-text-quiet);
    font-weight: var(--wa-font-weight-normal);
    margin-right: var(--wa-space-xs);
  }

  .file-actions {
    display: inline-flex;
    align-items: center;
    gap: var(--wa-space-2xs);
  }

  .action-icon {
    cursor: pointer;
    font-size: var(--wa-font-size-s);
    color: var(--wa-color-text-quieter);
    transition: color 0.2s ease;
  }

  .action-icon:hover {
    color: var(--wa-color-primary-600);
  }

  .copy-cid-icon:active {
    color: var(--wa-color-success-600);
  }

  /* Code viewer section */
  .code-viewer-section {
    margin-top: var(--wa-space-l);
  }

  .code-viewer {
    background: var(--wa-color-surface-lowered);
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    padding: var(--wa-space-m);
    overflow-x: auto;
  }

  .code-viewer pre {
    margin: 0;
    background: none;
    padding: 0;
  }

  .code-viewer code {
    font-family: var(--wa-font-family-code);
    font-size: var(--wa-font-size-s);
    line-height: var(--wa-line-height-relaxed);
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .publication-content {
      padding: var(--wa-space-m);
    }

    .frontmatter-background {
      padding: var(--wa-space-m);
    }
    .tab-content {
      padding: var(--wa-space-m);
    }

    .pdf-viewer iframe {
      height: 500px;
    }
  }

  /* Dark mode adjustments */
  .wa-dark .frontmatter-overlay {
    background: rgba(30, 30, 30, 0.95);
  }

  .project-logo {
    max-width: 100%;
    height: auto;
    border-radius: var(--wa-border-radius-l);
  }

  .desktop-search-container {
    display: block;
    width: 100%;
  }

  /* Show mobile search and hide desktop search on mobile */
  @media (max-width: 920px) {
    .desktop-search-container {
      display: none;
    }
  }

  .nav-logo {
    margin-bottom: var(--wa-space-m);
    text-align: center;
  }

  /* File Browser Grid Layout */
  .file-browser-grid {
    display: grid;
    grid-template-columns: 450px 1fr;
    gap: var(--wa-space-l);
    margin-top: var(--wa-space-l);
  }

  @media (max-width: 920px) {
    .file-browser-grid {
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
    }
  }

  /* File Tree Container */
  .file-tree-container {
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    background: var(--wa-color-surface-lowered);
    padding: var(--wa-space-m);
    overflow-y: auto;
    max-height: 1200px;
  }

  .file-tree {
    --indent-guide-width: 1px;
  }

  .file-size {
    font-size: var(--wa-font-size-xs);
    color: var(--wa-color-text-quiet);
    font-weight: var(--wa-font-weight-normal);
    margin-left: var(--wa-space-s);
  }

  /* File Preview Container */
  .file-preview-container {
    position: relative;
    min-height: 1200px;
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    background: var(--wa-color-surface-lowered);
  }

  .viewer-panel {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
  }

  .viewer-header {
    padding: var(--wa-space-m);
    border-bottom: 1px solid var(--wa-color-surface-border);
    background: var(--wa-color-surface-default);
  }

  .viewer-header h3 {
    margin: 0;
    font-size: var(--wa-font-size-m);
    font-weight: var(--wa-font-weight-semibold);
    color: var(--wa-color-text-normal);
  }

  /* Code Viewer */
  #code-viewer .code-content {
    flex: 1;
    overflow: auto;
    padding: 0;
    background: var(--wa-color-surface-lowered);
  }

  #code-viewer pre {
    margin: 0;
    padding: var(--wa-space-m);
    background: transparent;
    height: 100%;
  }

  #code-viewer code {
    font-family: var(--wa-font-family-code);
    font-size: var(--wa-font-size-s);
    line-height: var(--wa-line-height-relaxed);
    display: block;
  }

  /* Override highlight.js background to use our theme */
  #code-viewer .hljs {
    background: transparent;
    padding: 0;
  }

  /* Image Viewers */
  #niivue-canvas {
    width: 100%;
    height: 1200px;
    outline: none;
    border: none;
  }

  #image2d-viewer img {
    max-width: 100%;
    max-height: calc(1200px - 60px);
    object-fit: contain;
    padding: var(--wa-space-m);
  }

  /* No File Selected Message */
  #no-file-selected {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .no-file-message {
    text-align: center;
    color: var(--wa-color-text-quiet);
  }

  .no-file-message p {
    margin-top: var(--wa-space-m);
    font-size: var(--wa-font-size-m);
  }

  .selected-file {
    background: var(--wa-color-primary-surface);
  }

  /* Reviews content styling */
  .reviews-content {
    line-height: var(--wa-line-height-relaxed);
  }

  .reviews-content h1,
  .reviews-content h2 {
    color: var(--wa-color-text-loud);
    margin-top: var(--wa-space-l);
    margin-bottom: var(--wa-space-m);
    padding-bottom: var(--wa-space-s);
    border-bottom: 2px solid var(--wa-color-surface-border);
  }

  .reviews-content h1 {
    font-size: var(--wa-font-size-2xl);
  }

  .reviews-content h2 {
    font-size: var(--wa-font-size-xl);
  }

  .reviews-content p {
    margin-bottom: var(--wa-space-m);
  }

  .reviews-content strong {
    color: var(--wa-color-text-normal);
    font-weight: var(--wa-font-weight-bold);
  }

  .reviews-content ul,
  .reviews-content ol {
    margin-left: var(--wa-space-l);
    margin-bottom: var(--wa-space-m);
  }

  .reviews-content li {
    margin-bottom: var(--wa-space-xs);
  }

  .reviews-content pre {
    background: var(--wa-color-surface-lowered);
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    padding: var(--wa-space-m);
    overflow-x: auto;
    margin-bottom: var(--wa-space-m);
  }

  .reviews-content code {
    font-family: var(--wa-font-family-code);
    font-size: var(--wa-font-size-s);
  }

  /* Page Navigation (Previous/Next) */
  .page-navigation {
    display: flex;
    flex-direction: column;
    gap: var(--wa-space-m);
    margin-top: var(--wa-space-l);
    padding-top: var(--wa-space-l);
    border-top: 1px solid var(--wa-color-surface-border);
  }

  .nav-page-link {
    display: flex;
    align-items: center;
    gap: var(--wa-space-m);
    padding: var(--wa-space-s);
    border-radius: var(--wa-border-radius-m);
    text-decoration: none;
    color: var(--wa-color-text-normal);
    background: var(--wa-color-surface-lowered);
    border: 1px solid var(--wa-color-surface-border);
    transition: all 0.2s ease;
  }

  .nav-page-link:hover {
    background: var(--wa-color-surface-default);
    border-color: var(--wa-color-primary-600);
    transform: translateX(2px);
  }

  .prev-page:hover {
    transform: translateX(-2px);
  }

  .nav-page-thumbnail {
    flex-shrink: 0;
    width: 80px;
    height: 60px;
    border-radius: var(--wa-border-radius-s);
    overflow: hidden;
    background: var(--wa-color-surface-border);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .nav-page-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .nav-page-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    color: var(--wa-color-text-quieter);
    font-size: var(--wa-font-size-xl);
  }

  .nav-page-info {
    display: flex;
    flex-direction: column;
    gap: var(--wa-space-2xs);
    min-width: 0;
    flex: 1;
  }

  .nav-page-label {
    font-size: var(--wa-font-size-xs);
    color: var(--wa-color-text-quiet);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-weight: var(--wa-font-weight-semibold);
  }

  .nav-page-title {
    font-size: var(--wa-font-size-s);
    color: var(--wa-color-text-loud);
    font-weight: var(--wa-font-weight-medium);
    line-height: var(--wa-line-height-condensed);
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
  }

  .nav-page-link:hover .nav-page-title {
    color: var(--wa-color-primary-600);
  }

  /* Mobile navigation: hide sidebar nav, show below tabs */
  .page-navigation-mobile {
    display: none;
  }

  @media (max-width: 920px) {
    /* Hide navigation in sidebar on mobile */
    .page-navigation {
      display: none;
    }

    /* Show navigation below tabs on mobile */
    .page-navigation-mobile {
      display: flex;
      flex-direction: column;
      gap: var(--wa-space-m);
      margin-top: var(--wa-space-l);
      padding-top: var(--wa-space-l);
      border-top: 1px solid var(--wa-color-surface-border);
    }
  }
</style>
