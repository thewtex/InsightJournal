---
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 NumFOCUS

import BasePage from '@awesome-myst/myst-awesome/layouts/BasePage.astro';
import SearchDialog from '@awesome-myst/myst-awesome/components/SearchDialog.astro';
import NavigationMenu from '@awesome-myst/myst-awesome/components/NavigationMenu.astro';

import Authors from '../../../components/Authors.astro';
import Header from '../../../components/Header.astro';
import Footer from '../../../components/Footer.astro';

import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import { Image } from 'astro:assets';

import { generatePageUrl } from '@awesome-myst/myst-awesome/lib/generate-page-url.ts';

export async function getStaticPaths() {
  try {
    console.log('Starting getStaticPaths for [id].astro');

    const pages = await getCollection('pages');
    const projectConfig = (await getCollection('projectFrontmatter'))[0];

    console.log(`Total pages found: ${pages.length}`);

    const paths = pages.map((page, index) => {
      const id = page.id;

      console.log(`Processing page ${index + 1}: "${page.id}"`);
      console.log('Page contents:', page);

      return {
        params: { id },
        props: { page: page.data },
      };
    });

    console.log(`Generated ${paths.length} paths for [id].astro`);
    paths.forEach((path, i) => {
      console.log(`  Path ${i + 1}: id="${path.params.id}"`);
    });

    return paths;
  } catch (error) {
    console.error('Error in [id].astro getStaticPaths:', error);
    return [];
  }
}

interface PageProps {
  page: CollectionEntry<'pages'>;
}

const { page } = Astro.props as PageProps;

const allPages = await getCollection('pages');

console.log('page', page)

const title = page?.frontmatter?.title || 'Publication';
const abstract = page?.frontmatter?.abstract || '';
const frontmatter = page?.frontmatter;
const downloads = page?.downloads || [];

const foldersOption = false;
const baseDir = "/";
const showToc = typeof page.mdast.children !== "undefined";

import "../../../styles/custom.css";

import { mystParseAndRender } from '@awesome-myst/myst-awesome/lib/render-myst-ast';

// Create navigation items from all pages
const navItems = allPages
  .filter(p => p.id)
  .map(p => ({
    title: p.id === '/' ? 'Home' :
           (p.id.slice(1).charAt(0).toUpperCase() + p.id.slice(2)) || 'Page',
    href: generatePageUrl(p.id, foldersOption, baseDir),
    current: p.id === page.id,
    icon: p.id === '/' ? 'home' : 'file-text'
  }));

// Get prev/next pages for navigation
const currentIndex = allPages.findIndex(p => p.id === page.id);
const prevPage = currentIndex > 0 ? allPages[currentIndex - 1] : null;
const nextPage = currentIndex < allPages.length - 1 ? allPages[currentIndex + 1] : null;

// Process downloads to build file tree structure
const codeFiles = downloads.filter((d: any) => d.title?.startsWith('root/code/'));

// Build hierarchical tree structure from flat file list
interface TreeNode {
  name: string;
  path: string;
  type: 'file' | 'folder';
  url?: string;
  size?: string;
  children?: TreeNode[];
}

function buildFileTree(files: any[]): TreeNode[] {
  const root: TreeNode[] = [];
  const folderMap = new Map<string, TreeNode>();

  files.forEach((file: any) => {
    // Remove 'root/code/' prefix
    const relativePath = file.title.replace('root/code/', '');
    const parts = relativePath.split('/');
    const fileName = parts[parts.length - 1];

    // Build folder structure
    let currentPath = '';
    for (let i = 0; i < parts.length - 1; i++) {
      const folderName = parts[i];
      const parentPath = currentPath;
      currentPath = currentPath ? `${currentPath}/${folderName}` : folderName;

      if (!folderMap.has(currentPath)) {
        const folderNode: TreeNode = {
          name: folderName,
          path: currentPath,
          type: 'folder',
          children: []
        };
        folderMap.set(currentPath, folderNode);

        // Add to parent or root
        if (parentPath) {
          const parent = folderMap.get(parentPath);
          parent?.children?.push(folderNode);
        } else {
          root.push(folderNode);
        }
      }
    }

    // Add file
    const fileNode: TreeNode = {
      name: fileName,
      path: relativePath,
      type: 'file',
      url: file.url,
      size: file.extra?.size_bytes ? formatBytes(file.extra.size_bytes) : undefined
    };

    if (parts.length === 1) {
      root.push(fileNode);
    } else {
      const parentPath = parts.slice(0, -1).join('/');
      const parent = folderMap.get(parentPath);
      parent?.children?.push(fileNode);
    }
  });

  return root;
}

function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${Math.round(bytes / Math.pow(k, i) * 10) / 10} ${sizes[i]}`;
}

const fileTree = buildFileTree(codeFiles);

// Determine medical imaging file extensions
const medicalImageExtensions = ['.nii', '.nii.gz', '.dcm', '.nrrd', '.mha', '.mhd', '.vtk', '.vti', '.aim', '.isq', '.gipl', '.gipl.gz', '.hdf5', '.iwi', '.iwi.cbor', '.iwi.cbor.zst', '.lsm', '.mnc', '.mnc.gz', '.mgh', '.mgz', '.mgh.gz', '.mrc', '.pic', '.fdf', '.stl', '.ply', '.mz3', '.off', '.obj', '.fsa', '.fsb', '.byu', '.swc', '.fz', '.gqi', '.qsdr', '.mih', '.mif', '.src', '.v', '.v16', '.vmr', '.head', '.tract', '.tt', '.trx', '.trk', '.tck', '.annot', '.x3d'];
const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.tif'];
const codeExtensions = ['.py', '.cxx', '.cpp', '.h', '.hxx', '.txx', '.hpp', '.c', '.js', '.ts', '.java', '.cs', '.md', '.txt', '.cmake', '.json', '.xml', '.yaml', '.yml'];

function getFileExtension(filename: string): string {
  // Check for complex multi-dot extensions first
  const complexExtensions = ['.nii.gz', '.gipl.gz', '.mnc.gz', '.mgh.gz', '.iwi.cbor', '.iwi.cbor.zst'];
  for (const ext of complexExtensions) {
    if (filename.endsWith(ext)) return ext;
  }

  // Fall back to simple extension matching
  const match = filename.match(/\.([^.]+)$/);
  return match ? `.${match[1]}` : '';
}

function isMedicalImage(filename: string): boolean {
  const ext = getFileExtension(filename);
  return medicalImageExtensions.some(e => filename.endsWith(e));
}

function isImage(filename: string): boolean {
  const ext = getFileExtension(filename);
  return imageExtensions.includes(ext.toLowerCase());
}

function isCodeFile(filename: string): boolean {
  const ext = getFileExtension(filename);
  return codeExtensions.includes(ext.toLowerCase()) || !isMedicalImage(filename) && !isImage(filename);
}

// Find default file to display
let defaultFile: TreeNode | null = null;

function findDefaultFile(nodes: TreeNode[]): TreeNode | null {
  for (const node of nodes) {
    if (node.type === 'file') {
      if (isMedicalImage(node.name)) return node;
    }
    if (node.children) {
      const found = findDefaultFile(node.children);
      if (found && isMedicalImage(found.name)) return found;
    }
  }

  // If no medical image, try regular image
  for (const node of nodes) {
    if (node.type === 'file') {
      if (isImage(node.name)) return node;
    }
    if (node.children) {
      const found = findDefaultFile(node.children);
      if (found && isImage(found.name)) return found;
    }
  }

  // Otherwise, first code file
  for (const node of nodes) {
    if (node.type === 'file') return node;
    if (node.children) {
      const found = findDefaultFile(node.children);
      if (found) return found;
    }
  }

  return null;
}

defaultFile = findDefaultFile(fileTree);

// Function to replace email addresses with icon links
function replaceEmailsWithIcons(html: string): string {
  // Regex to find email addresses (both in links and plain text)
  const emailRegex = /(<a[^>]*href=["']mailto:([^"']+)["'][^>]*>)([^<]+)(<\/a>)|([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g;

  return html.replace(emailRegex, (match, linkStart, linkEmail, linkText, linkEnd, plainEmail) => {
    if (plainEmail) {
      // Replace plain email with icon link
      return `<a href="mailto:${plainEmail}" title="Email" style="color: var(--wa-color-text-quiet); transition: color 0.2s; margin-left: var(--wa-space-2xs); text-decoration: none;" onmouseover="this.style.color='var(--wa-color-primary-600)'" onmouseout="this.style.color='var(--wa-color-text-quiet)'"><wa-icon library="scienceicons" name="email" style="font-size: 0.875rem; vertical-align: middle;"></wa-icon></a>`;
    } else if (linkStart && linkEmail) {
      // Replace email link with icon link
      return `<a href="mailto:${linkEmail}" title="Email" style="color: var(--wa-color-text-quiet); transition: color 0.2s; margin-left: var(--wa-space-2xs); text-decoration: none;" onmouseover="this.style.color='var(--wa-color-primary-600)'" onmouseout="this.style.color='var(--wa-color-text-quiet)'"><wa-icon library="scienceicons" name="email" style="font-size: 0.875rem; vertical-align: middle;"></wa-icon></a>`;
    }
    return match;
  });
}

// Check if reviews.md exists in downloads
const reviewsFile = downloads.find((d: any) => d.title === 'root/reviews.md');
let reviewsContent = '';

console.log('Checking for reviews file...', reviewsFile);
console.log('All downloads:', downloads.map((d: any) => d.title));

if (reviewsFile?.url) {
  try {
    console.log('Fetching reviews from:', reviewsFile.url);
    const response = await fetch(reviewsFile.url);
    const reviewsMarkdown = await response.text();
    console.log('Reviews markdown length:', reviewsMarkdown.length);
    let renderedContent = await mystParseAndRender(reviewsMarkdown);
    // Replace emails with icon links
    reviewsContent = replaceEmailsWithIcons(renderedContent);
    console.log('Rendered reviews content length:', reviewsContent.length);
  } catch (error) {
    console.error('Error fetching or parsing reviews:', error);
  }
}

// Helper function to get icon name based on file extension
function getFileIcon(filename: string): string {
  const ext = getFileExtension(filename).toLowerCase();

  // Medical imaging formats
  if (medicalImageExtensions.some(e => filename.endsWith(e))) return 'file-zipper';

  // Images
  if (imageExtensions.includes(ext)) return 'file-image';

  // Code files
  const codeIconMap: Record<string, string> = {
    '.py': 'file-code',
    '.cpp': 'file-code',
    '.cxx': 'file-code',
    '.h': 'file-code',
    '.hxx': 'file-code',
    '.txx': 'file-code',
    '.hpp': 'file-code',
    '.c': 'file-code',
    '.js': 'file-code',
    '.ts': 'file-code',
    '.java': 'file-code',
    '.cs': 'file-code',
    '.cmake': 'file-code',
    '.json': 'file-code',
    '.xml': 'file-code',
    '.yaml': 'file-code',
    '.yml': 'file-code',
    '.md': 'file-lines',
    '.txt': 'file-lines',
  };

  return codeIconMap[ext] || 'file';
}
---

<!-- Recursive component for rendering file tree nodes -->
{fileTree.length > 0 && (
  <script is:inline define:vars={{ fileTree, defaultFile }}>
    // Store file tree data globally for access in event handlers
    window.fileTreeData = fileTree;
    window.defaultFileData = defaultFile;
  </script>
)}

{/* Helper component to render tree nodes recursively */}
---

<!-- Actual file tree will be rendered in the template below -->

<BasePage
  title={title}
  description={abstract}
  theme="default"
  colorScheme="auto"
  mobileBreakpoint="920px"
>
  <Header slot="header" />

  <!-- Navigation with search -->
  <div slot="navigation-header" class="nav-header">
    <div class="nav-logo">
      <img
        src="/assets/logo-insight-journal-square-dark.png"
        alt="Insight Journal logo"
        class="project-logo theme-aware-logo"
      />
    </div>
    <!-- Desktop search (hidden on mobile) -->
    <div class="desktop-search-container ij-nav-search">
      <SearchDialog foldersOption={false} />
    </div>
  </div>

  <!-- Main content -->
  <div class="publication-content">
    <!-- Frontmatter Block with fancy background -->
    <div class="frontmatter-container">
      <div class="frontmatter-background">
        <div class="frontmatter-overlay">
          <!-- Publication metadata header -->
          <div class="publication-metadata">
            <div class="metadata-left">
              <span class="article-type">Open Science Article</span>
              {frontmatter?.date_submitted && (
                <span class="submitted-date">
                  Submitted: {new Date(frontmatter.date_submitted).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                  })}
                </span>
              )}
              {page?.doi && (
                <a
                  href={`https://doi.org/${page.doi}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  class="doi-link"
                >
                  {`https://doi.org/${page.doi}`}
                </a>
              )}
            </div>
            <div class="metadata-right">
              <wa-icon library="scienceicons" name="open-access" class="openaccess-icon"></wa-icon>
            </div>
          </div>

          <header>
            <h1 class="publication-title">{title}</h1>
          </header>
          <Authors authors={frontmatter?.authors} />
        </div>
      </div>
    </div>

    <!-- Tab Group for content sections -->
    <wa-tab-group class="content-tabs">
      <!-- Abstract Tab -->
      <wa-tab slot="nav" panel="abstract">Abstract</wa-tab>
      <wa-tab-panel name="abstract">
        <div class="tab-content">
          <h2>Abstract</h2>
          <p>{abstract}</p>
          {frontmatter?.keywords && (
            <div class="keywords">
              <h3>Keywords</h3>
              <div class="keyword-tags">
                {frontmatter.keywords.map((keyword: string) => (
                  <wa-badge variant="neutral">{keyword}</wa-badge>
                ))}
              </div>
            </div>
          )}
        </div>
      </wa-tab-panel>

      <!-- Manuscript Tab -->
      <wa-tab slot="nav" panel="manuscript">Manuscript</wa-tab>
      <wa-tab-panel name="manuscript">
        <div class="tab-content">
          <div class="pdf-viewer">
            <iframe
              src={`/pdfs/${page.slug}.pdf`}
              width="100%"
              height="1200px"
              style="border: none;"
              title="Article PDF"
            ></iframe>
          </div>
        </div>
      </wa-tab-panel>

      <!-- Source Code and Data Tab -->
      <wa-tab slot="nav" panel="files">Source Code and Data</wa-tab>
      <wa-tab-panel name="files">
        <div class="tab-content">
          <h2>Source Code and Data</h2>

          {codeFiles.length > 0 ? (
            <div class="file-browser-grid">
              <!-- Left side: File Tree -->
              <div class="file-tree-container">
                <wa-tree class="file-tree" id="file-tree" selection="single">
                  {fileTree.map((node) => (
                    <>
                      {node.type === 'folder' ? (
                        <wa-tree-item data-path={node.path} data-type="folder">
                          <wa-icon name="folder" variant="regular"></wa-icon>
                          {node.name}
                          {node.children?.map((child) => (
                            <>
                              {child.type === 'folder' ? (
                                <wa-tree-item data-path={child.path} data-type="folder">
                                  <wa-icon name="folder" variant="regular"></wa-icon>
                                  {child.name}
                                  {child.children?.map((grandchild) => (
                                    <wa-tree-item
                                      data-path={grandchild.path}
                                      data-type={grandchild.type}
                                      data-url={grandchild.url}
                                      class={grandchild.url === defaultFile?.url ? 'selected-file' : ''}
                                    >
                                      <wa-icon name={getFileIcon(grandchild.name)} variant="regular"></wa-icon>
                                      {grandchild.name}
                                      {grandchild.size && <span slot="end" class="file-size">{grandchild.size}</span>}
                                    </wa-tree-item>
                                  ))}
                                </wa-tree-item>
                              ) : (
                                <wa-tree-item
                                  data-path={child.path}
                                  data-type={child.type}
                                  data-url={child.url}
                                  class={child.url === defaultFile?.url ? 'selected-file' : ''}
                                >
                                  <wa-icon name={getFileIcon(child.name)} variant="regular"></wa-icon>
                                  {child.name}
                                  {child.size && <span slot="end" class="file-size">{child.size}</span>}
                                </wa-tree-item>
                              )}
                            </>
                          ))}
                        </wa-tree-item>
                      ) : (
                        <wa-tree-item
                          data-path={node.path}
                          data-type={node.type}
                          data-url={node.url}
                          class={node.url === defaultFile?.url ? 'selected-file' : ''}
                        >
                          <wa-icon name={getFileIcon(node.name)} variant="regular"></wa-icon>
                          {node.name}
                          {node.size && <span slot="end" class="file-size">{node.size}</span>}
                        </wa-tree-item>
                      )}
                    </>
                  ))}
                </wa-tree>
              </div>

              <!-- Right side: File Preview -->
              <div class="file-preview-container">
                <!-- Code viewer -->
                <div id="code-viewer" class="viewer-panel" style="display: none;">
                  <div class="viewer-header">
                    <h3 id="code-viewer-title">File</h3>
                  </div>
                  <div class="code-content">
                    <pre><code id="code-viewer-content"></code></pre>
                  </div>
                </div>

                <!-- Medical/3D Image viewer -->
                <div id="image-viewer" class="viewer-panel" style="display: none;">
                  <div class="viewer-header">
                    <h3 id="image-viewer-title">Image</h3>
                  </div>
                  <canvas id="niivue-canvas"></canvas>
                </div>

                <!-- 2D Image viewer -->
                <div id="image2d-viewer" class="viewer-panel" style="display: none;">
                  <div class="viewer-header">
                    <h3 id="image2d-viewer-title">Image</h3>
                  </div>
                  <img id="image2d-content" alt="Preview" />
                </div>

                <!-- Initial message -->
                <div id="no-file-selected" class="viewer-panel">
                  <div class="no-file-message">
                    <wa-icon name="file-code" style="font-size: 4rem; opacity: 0.3;"></wa-icon>
                    <p>Select a file to preview</p>
                  </div>
                </div>
              </div>
            </div>
          ) : (
            <p>No source code files available for this publication.</p>
          )}
        </div>
      </wa-tab-panel>

      <!-- Reviews Tab (only show if reviews exist) -->
      {reviewsContent && <wa-tab slot="nav" panel="reviews">Reviews</wa-tab>}
      {reviewsContent && (
        <wa-tab-panel name="reviews">
          <div class="tab-content">
            <div class="reviews-content" set:html={reviewsContent} />
          </div>
        </wa-tab-panel>
      )}
    </wa-tab-group>
  </div>

  <!-- Footer -->
  <Footer slot="footer" />
</BasePage>

<script>
  // Import Web Awesome components
  import '@awesome.me/webawesome/dist/components/tab-group/tab-group.js';
  import '@awesome.me/webawesome/dist/components/tab/tab.js';
  import '@awesome.me/webawesome/dist/components/tab-panel/tab-panel.js';
  import '@awesome.me/webawesome/dist/components/tree/tree.js';
  import '@awesome.me/webawesome/dist/components/tree-item/tree-item.js';
  import '@awesome.me/webawesome/dist/components/badge/badge.js';

  import { Niivue, SLICE_TYPE, MULTIPLANAR_TYPE, SHOW_RENDER } from "@niivue/niivue";
  import { useItkWasmLoaders, createImageLoader } from '@niivue/itkwasm-loader';
  import { dicomLoader } from '@niivue/dicom-loader';

  // Theme-aware logo switching functionality
  document.addEventListener('DOMContentLoaded', async () => {
    // Theme-aware logo switching
    const updateLogoForTheme = () => {
      const isDark = document.documentElement.classList.contains('wa-dark');
      const logoElement = document.querySelector('.theme-aware-logo') as HTMLImageElement;

      if (logoElement) {
        if (isDark) {
          logoElement.src = '/assets/logo-insight-journal-square-dark.png';
        } else {
          logoElement.src = '/assets/logo-insight-journal-square-light.png';
        }
      }
    };

    updateLogoForTheme();

    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          updateLogoForTheme();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });

    // File browser functionality
    let nv: Niivue | null = null;
    let currentViewerType: 'code' | 'image3d' | 'image2d' | 'none' = 'none';

    // Initialize NiiVue
    const initializeNiiVue = async () => {
      if (!nv) {
        const isDark = document.documentElement.classList.contains('wa-dark');
        const defaults = {
          backColor: isDark ? [16.0/255.0, 18.0/255.0, 25.0/255.0, 1.0] : [1, 1, 1, 1],
          logLevel: 'info' as const,
          showLegend: true,
          showColorbarBorder: false,
          isColorBar: true,
          isOrientCube: true,
          isOrientationTextVisible: false,
          sliceType: SLICE_TYPE.MULTIPLANAR,
          multiplanarRender: MULTIPLANAR_TYPE.GRID,
          multiplanarShowRender: SHOW_RENDER.ALWAYS,
          heroImageFraction: 0.6,
        };
        nv = new Niivue(defaults);
        const canvas = document.getElementById("niivue-canvas") as HTMLCanvasElement;
        if (canvas) {
          await nv.attachToCanvas(canvas);
          useItkWasmLoaders(nv);
          nv.useDicomLoader(dicomLoader);
        }
      }
    };

    // Show specific viewer
    const showViewer = (type: 'code' | 'image3d' | 'image2d' | 'none') => {
      document.getElementById('code-viewer')!.style.display = type === 'code' ? 'block' : 'none';
      document.getElementById('image-viewer')!.style.display = type === 'image3d' ? 'block' : 'none';
      document.getElementById('image2d-viewer')!.style.display = type === 'image2d' ? 'block' : 'none';
      document.getElementById('no-file-selected')!.style.display = type === 'none' ? 'flex' : 'none';
      currentViewerType = type;
    };

    // Helper function to find companion file for MHD/RAW pairs
    const findCompanionFile = (filename: string, fileTreeData: any[]): string | null => {
      const baseNameMatch = filename.match(/^(.+)\.(mhd|raw)$/i);
      if (!baseNameMatch) return null;

      const baseName = baseNameMatch[1];
      const currentExt = baseNameMatch[2].toLowerCase();
      const companionExt = currentExt === 'mhd' ? 'raw' : 'mhd';
      const companionFilename = `${baseName}.${companionExt}`;

      // Search recursively in the file tree
      const searchTree = (nodes: any[]): string | null => {
        for (const node of nodes) {
          if (node.type === 'file' && node.name.toLowerCase() === companionFilename.toLowerCase()) {
            return node.url;
          }
          if (node.children) {
            const found = searchTree(node.children);
            if (found) return found;
          }
        }
        return null;
      };

      return searchTree(fileTreeData);
    };

    // Helper function to combine MHD and RAW files into MHA format
    const combineMhdRawToMha = async (mhdUrl: string, rawUrl: string, baseName: string): Promise<{ buffer: ArrayBuffer, name: string }> => {
      // Fetch both files
      const [mhdResponse, rawResponse] = await Promise.all([
        fetch(mhdUrl),
        fetch(rawUrl)
      ]);

      // Get MHD text and RAW binary data
      const mhdText = await mhdResponse.text();
      const rawBuffer = await rawResponse.arrayBuffer();

      // Edit MHD header to replace ElementDataFile line
      const lines = mhdText.split('\n');
      const editedLines = lines.map(line => {
        if (line.trim().startsWith('ElementDataFile')) {
          return 'ElementDataFile = LOCAL';
        }
        return line;
      });
      const editedMhd = editedLines.join('\n');

      // Convert edited MHD text to ArrayBuffer
      const encoder = new TextEncoder();
      const mhdBuffer = encoder.encode(editedMhd);

      // Concatenate MHD header and RAW data
      const combinedBuffer = new ArrayBuffer(mhdBuffer.byteLength + rawBuffer.byteLength);
      const combinedView = new Uint8Array(combinedBuffer);
      combinedView.set(new Uint8Array(mhdBuffer), 0);
      combinedView.set(new Uint8Array(rawBuffer), mhdBuffer.byteLength);

      // Create MHA filename
      const mhaName = `${baseName}.mha`;

      console.log(`Combined MHD/RAW into MHA: ${mhaName} (${combinedBuffer.byteLength} bytes)`);

      return { buffer: combinedBuffer, name: mhaName };
    };

    // Load and display a file
    const loadFile = async (url: string, filename: string) => {
      const ext = filename.toLowerCase();

      // Check if it's a medical image or mesh
      const medicalExts = ['.nii', '.nii.gz', '.dcm', '.nrrd', '.mha', '.mhd', '.vtk', '.vti', '.aim', '.isq', '.gipl', '.gipl.gz', '.hdf5', '.iwi', '.iwi.cbor', '.iwi.cbor.zst', '.lsm', '.mnc', '.mnc.gz', '.mgh', '.mgz', '.mgh.gz', '.mrc', '.pic', '.fdf', '.stl', '.ply', '.mz3', '.off', '.obj', '.fsa', '.fsb', '.byu', '.swc', '.fz', '.gqi', '.qsdr', '.mih', '.mif', '.src', '.v', '.v16', '.vmr', '.head', '.tract', '.tt', '.trx', '.trk', '.tck', '.annot', '.x3d'];
      const isMedical = medicalExts.some(e => ext.endsWith(e));

      // Check if it's a regular image
      const imageExts = ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.tif'];
      const isImage = imageExts.some(e => ext.endsWith(e));

      if (isMedical) {
        // Load with NiiVue
        await initializeNiiVue();
        showViewer('image3d');
        document.getElementById('image-viewer-title')!.textContent = filename;

        try {
          if (nv) {
            // Check if it's a DICOM file - use loadDicoms instead of loadVolumes
            if (ext.endsWith('.dcm')) {
              if (nv.volumes.length > 0) {
                nv.removeVolumeByIndex(0);
              }
              await nv.loadDicoms([{ url, name: filename }]);
            } else {
              if (nv.volumes.length > 0) {
                nv.removeVolumeByIndex(0);
              }

              // Check for MHD/RAW companion files and combine them
              if (ext.endsWith('.mhd') || ext.endsWith('.raw')) {
                const companionUrl = findCompanionFile(filename, (window as any).fileTreeData);
                if (companionUrl) {
                  // Determine which is MHD and which is RAW
                  const isMhd = ext.endsWith('.mhd');
                  const mhdUrl = isMhd ? url : companionUrl;
                  const rawUrl = isMhd ? companionUrl : url;
                  const baseName = filename.replace(/\.(mhd|raw)$/i, '');

                  // Combine into MHA format
                  const { buffer, name: mhaName } = await combineMhdRawToMha(mhdUrl, rawUrl, baseName);

                  // Create Blob and object URL from the combined buffer
                  const blob = new Blob([buffer], { type: 'application/octet-stream' });
                  const objectUrl = URL.createObjectURL(blob);

                  // Load the combined MHA buffer
                  await nv.loadVolumes([{ url: objectUrl, name: mhaName }]);

                  // Clean up object URL after loading
                  URL.revokeObjectURL(objectUrl);
                } else {
                  // No companion found, try loading as-is
                  await nv.loadVolumes([{ url, name: filename }]);
                }
              } else {
                // Regular medical image file
                await nv.loadVolumes([{ url, name: filename }]);
              }
            }
            // needed?
            nv.resizeListener();
            nv.drawScene();
          }
        } catch (error) {
          console.error('Error loading medical image:', error);
        }
      } else if (isImage) {
        // Load as regular image
        showViewer('image2d');
        document.getElementById('image2d-viewer-title')!.textContent = filename;
        const img = document.getElementById('image2d-content') as HTMLImageElement;
        img.src = url;
      } else {
        // Load as code/text
        showViewer('code');
        document.getElementById('code-viewer-title')!.textContent = filename;

        try {
          const response = await fetch(url);
          const text = await response.text();
          const codeElement = document.getElementById('code-viewer-content')!;
          codeElement.textContent = text;

          // Add line numbers
          const lines = text.split('\n');
          const numberedLines = lines.map((line, i) =>
            `<span class="line-number">${i + 1}</span>${escapeHtml(line)}`
          ).join('\n');
          codeElement.innerHTML = numberedLines;
        } catch (error) {
          console.error('Error loading file:', error);
          document.getElementById('code-viewer-content')!.textContent = 'Error loading file';
        }
      }
    };

    // Escape HTML for code display
    const escapeHtml = (text: string) => {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    };

    // Handle file tree clicks
    const fileTree = document.getElementById('file-tree');
    if (fileTree) {
      fileTree.addEventListener('wa-selection-change', (event: any) => {
        const selectedItems = event.detail.selection;
        if (selectedItems.length > 0) {
          const item = selectedItems[0];
          const url = item.dataset.url;
          const type = item.dataset.type;
          const path = item.dataset.path;

          if (type === 'file' && url) {
            const filename = path.split('/').pop() || 'file';
            loadFile(url, filename);
          }
        }
      });
    }

    // Load default file when Source Code tab is activated
    const tabGroup = document.querySelector('wa-tab-group');
    if (tabGroup) {
      tabGroup.addEventListener('wa-tab-show', async (event: any) => {
        const tabName = event.detail.name;

        // Update URL when tab is clicked
        if (tabName && ['abstract', 'manuscript', 'files', 'reviews'].includes(tabName)) {
          history.pushState(null, '', `#${tabName}`);
        }

        if (tabName === 'files') {
          // Load default file if available
          const defaultFileEl = document.querySelector('.selected-file') as HTMLElement;
          if (defaultFileEl && currentViewerType === 'none') {
            const url = defaultFileEl.dataset.url;
            const path = defaultFileEl.dataset.path;
            if (url && path) {
              const filename = path.split('/').pop() || 'file';
              await loadFile(url, filename);
            }
          }
        }
      });
    }

    // Handle hash navigation for tabs
    const handleTabFromHash = () => {
      const hash = window.location.hash.substring(1); // Remove the # symbol
      if (hash && ['abstract', 'manuscript', 'files', 'reviews'].includes(hash)) {
        const tabGroup = document.querySelector('wa-tab-group');
        const targetTab = document.querySelector(`wa-tab[panel="${hash}"]`);

        if (tabGroup && targetTab) {
          // Activate the tab
          (targetTab as any).click();
        }
      }
    };

    // Handle initial hash on page load
    handleTabFromHash();

    // Handle hash changes
    window.addEventListener('hashchange', handleTabFromHash);
  });
</script>

<style>
  /* Navigation search */
  .ij-nav-search {
    padding: var(--wa-space-m);
    border-bottom: 1px solid var(--wa-color-surface-border);
  }

  .nav-search {
    width: 100%;
  }

  /* Publication content */
  .publication-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: var(--wa-space-l);
  }

  /* Frontmatter container with fancy background */
  .frontmatter-container {
    margin-bottom: var(--wa-space-2xl);
  }

  .frontmatter-background {
    background: linear-gradient(135deg, #064f8d 0%, #2d3748 100%);
    border-radius: var(--wa-border-radius-m);
    padding: var(--wa-space-l);
    position: relative;
    overflow: hidden;
  }

  .frontmatter-background::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
    pointer-events: none;
  }

  .frontmatter-overlay {
    position: relative;
    z-index: 1;
    background: var(--wa-color-surface-default);
    backdrop-filter: blur(10px);
    border-radius: var(--wa-border-radius-l);
    padding: var(--wa-space-l);
    box-shadow: var(--wa-shadow-l);
  }

  .publication-title {
    font-size: var(--wa-font-size-xl);
    font-weight: var(--wa-font-weight-bold);
    color: var(--wa-color-text-loud);
    margin: 0 0 var(--wa-space-m) 0;
    line-height: var(--wa-line-height-condensed);
  }

  /* Publication metadata header */
  .publication-metadata {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--wa-space-l);
    padding-bottom: var(--wa-space-m);
    border-bottom: 1px solid var(--wa-color-surface-border);
    font-size: var(--wa-font-size-s);
  }

  .metadata-left {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: var(--wa-space-m);
    color: var(--wa-color-text-quiet);
  }

  .metadata-right {
    display: flex;
    align-items: center;
  }

  .article-type {
    font-variant: small-caps;
    font-weight: var(--wa-font-weight-semibold);
    color: var(--wa-color-text-normal);
    letter-spacing: 0.05em;
  }

  .submitted-date {
    color: var(--wa-color-text-quiet);
  }

  .doi-link {
    color: var(--wa-color-primary-600);
    text-decoration: none;
    transition: color 0.2s;
  }

  .doi-link:hover {
    color: var(--wa-color-primary-700);
    text-decoration: underline;
  }

  .openaccess-icon {
    font-size: var(--wa-font-size-l);
    color: var(--wa-color-success-600);
  }

  /* Responsive adjustments for metadata */
  @media (max-width: 768px) {
    .publication-metadata {
      flex-direction: column;
      align-items: flex-start;
      gap: var(--wa-space-s);
    }

    .metadata-left {
      flex-direction: column;
      align-items: flex-start;
      gap: var(--wa-space-xs);
    }

    .metadata-right {
      align-self: flex-end;
    }
  }

  /* Content tabs */
  .content-tabs {
    --track-color: var(--wa-color-surface-border);
    --indicator-color: #ff6b35;
  }

  .tab-content {
    padding: var(--wa-space-l);
    background: var(--wa-color-surface-default);
    border-radius: var(--wa-border-radius-l);
    margin-top: var(--wa-space-m);
  }

  .tab-content h2 {
    color: var(--wa-color-text-normal);
    margin-bottom: var(--wa-space-m);
    font-size: var(--wa-font-size-2xl);
  }

  .tab-content h3 {
    color: var(--wa-color-text-normal);
    margin-bottom: var(--wa-space-s);
    font-size: var(--wa-font-size-xl);
  }

  /* Keywords section */
  .keywords {
    margin-top: var(--wa-space-l);
  }

  .keyword-tags {
    display: flex;
    flex-wrap: wrap;
    gap: var(--wa-space-xs);
    margin-top: var(--wa-space-s);
  }

  /* PDF viewer */
  .pdf-viewer {
    border-radius: var(--wa-border-radius-m);
    overflow: hidden;
    box-shadow: var(--wa-shadow-m);
  }

  /* File tree section */
  .file-tree-section {
    margin-bottom: var(--wa-space-2xl);
  }

  .file-tree {
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    background: var(--wa-color-surface-lowered);
  }

  .file-size {
    font-size: var(--wa-font-size-xs);
    color: var(--wa-color-text-quiet);
    font-weight: var(--wa-font-weight-normal);
  }

  /* Code viewer section */
  .code-viewer-section {
    margin-top: var(--wa-space-l);
  }

  .code-viewer {
    background: var(--wa-color-surface-lowered);
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    padding: var(--wa-space-m);
    overflow-x: auto;
  }

  .code-viewer pre {
    margin: 0;
    background: none;
    padding: 0;
  }

  .code-viewer code {
    font-family: var(--wa-font-family-code);
    font-size: var(--wa-font-size-s);
    line-height: var(--wa-line-height-relaxed);
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .publication-content {
      padding: var(--wa-space-m);
    }

    .frontmatter-background {
      padding: var(--wa-space-m);
    }

    .tab-content {
      padding: var(--wa-space-m);
    }

    .pdf-viewer iframe {
      height: 500px;
    }
  }

  /* Dark mode adjustments */
  .wa-dark .frontmatter-overlay {
    background: rgba(30, 30, 30, 0.95);
  }

  .project-logo {
    max-width: 100%;
    height: auto;
    border-radius: var(--wa-border-radius-l);
  }

  .desktop-search-container {
    display: block;
    width: 100%;
  }

  /* Show mobile search and hide desktop search on mobile */
  @media (max-width: 920px) {
    .desktop-search-container {
      display: none;
    }
  }

  .nav-logo {
    margin-bottom: var(--wa-space-m);
    text-align: center;
  }

  /* File Browser Grid Layout */
  .file-browser-grid {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: var(--wa-space-l);
    margin-top: var(--wa-space-l);
  }

  @media (max-width: 920px) {
    .file-browser-grid {
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
    }
  }

  /* File Tree Container */
  .file-tree-container {
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    background: var(--wa-color-surface-lowered);
    padding: var(--wa-space-m);
    overflow-y: auto;
    max-height: 1200px;
  }

  .file-tree {
    --indent-guide-width: 1px;
  }

  .file-size {
    font-size: var(--wa-font-size-xs);
    color: var(--wa-color-text-quiet);
    font-weight: var(--wa-font-weight-normal);
    margin-left: var(--wa-space-s);
  }

  /* File Preview Container */
  .file-preview-container {
    position: relative;
    min-height: 1200px;
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    background: var(--wa-color-surface-lowered);
  }

  .viewer-panel {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
  }

  .viewer-header {
    padding: var(--wa-space-m);
    border-bottom: 1px solid var(--wa-color-surface-border);
    background: var(--wa-color-surface-default);
  }

  .viewer-header h3 {
    margin: 0;
    font-size: var(--wa-font-size-m);
    font-weight: var(--wa-font-weight-semibold);
    color: var(--wa-color-text-normal);
  }

  /* Code Viewer */
  #code-viewer .code-content {
    flex: 1;
    overflow: auto;
    padding: var(--wa-space-m);
  }

  #code-viewer pre {
    margin: 0;
    background: none;
    padding: 0;
  }

  #code-viewer code {
    font-family: var(--wa-font-family-code);
    font-size: var(--wa-font-size-s);
    line-height: var(--wa-line-height-relaxed);
    display: block;
  }

  #code-viewer .line-number {
    display: inline-block;
    width: 3em;
    text-align: right;
    margin-right: 1em;
    color: var(--wa-color-text-quiet);
    user-select: none;
    border-right: 1px solid var(--wa-color-surface-border);
    padding-right: 0.5em;
  }

  /* Image Viewers */
  #niivue-canvas {
    width: 100%;
    height: 1200px;
    outline: none;
    border: none;
  }

  #image2d-viewer img {
    max-width: 100%;
    max-height: calc(1200px - 60px);
    object-fit: contain;
    padding: var(--wa-space-m);
  }

  /* No File Selected Message */
  #no-file-selected {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .no-file-message {
    text-align: center;
    color: var(--wa-color-text-quiet);
  }

  .no-file-message p {
    margin-top: var(--wa-space-m);
    font-size: var(--wa-font-size-m);
  }

  .selected-file {
    background: var(--wa-color-primary-surface);
  }

  /* Reviews content styling */
  .reviews-content {
    line-height: var(--wa-line-height-relaxed);
  }

  .reviews-content h1,
  .reviews-content h2 {
    color: var(--wa-color-text-loud);
    margin-top: var(--wa-space-l);
    margin-bottom: var(--wa-space-m);
    padding-bottom: var(--wa-space-s);
    border-bottom: 2px solid var(--wa-color-surface-border);
  }

  .reviews-content h1 {
    font-size: var(--wa-font-size-2xl);
  }

  .reviews-content h2 {
    font-size: var(--wa-font-size-xl);
  }

  .reviews-content p {
    margin-bottom: var(--wa-space-m);
  }

  .reviews-content strong {
    color: var(--wa-color-text-normal);
    font-weight: var(--wa-font-weight-bold);
  }

  .reviews-content ul,
  .reviews-content ol {
    margin-left: var(--wa-space-l);
    margin-bottom: var(--wa-space-m);
  }

  .reviews-content li {
    margin-bottom: var(--wa-space-xs);
  }

  .reviews-content pre {
    background: var(--wa-color-surface-lowered);
    border: 1px solid var(--wa-color-surface-border);
    border-radius: var(--wa-border-radius-m);
    padding: var(--wa-space-m);
    overflow-x: auto;
    margin-bottom: var(--wa-space-m);
  }

  .reviews-content code {
    font-family: var(--wa-font-family-code);
    font-size: var(--wa-font-size-s);
  }
</style>
