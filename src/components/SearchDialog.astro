---
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2025 Fideus Labs LLC
---

<div class="search-launcher">
  <!-- <wa-input class="nav-search" placeholder="Search" size="medium" type="text" appearance="outlined">
    <wa-icon slot="start" name="magnifying-glass"></wa-icon>
    <kbd slot="end" class="search-shortcut">/</kbd>
  </wa-input> -->

  <wa-dialog class="search-dialog" label="Search" no-header>
    <div class="search-container">
      <div class="search-left">
        <div class="search-top">
          <wa-input class="search-input" placeholder="Type to search…" size="medium">
            <wa-icon slot="start" name="magnifying-glass"></wa-icon>
          </wa-input>
          <div class="keys-help">
            <span><kbd>↑</kbd><kbd>↓</kbd> to navigate</span>
            <span><kbd>Enter</kbd> to open</span>
            <span><kbd>Esc</kbd> to close</span>
          </div>
        </div>
        <ul class="results" role="listbox" aria-label="Search results"></ul>
      </div>
      <div class="search-right">
        <div class="preview-header">
          <span class="preview-title">Preview</span>
        </div>
        <div class="preview-frame">
          <wa-zoomable-frame class="preview-iframe" title="Result preview" zoom="0.3" zoom-levels="0.3 0.4 0.5 0.75 1.0" loading="lazy"></wa-zoomable-frame>
        </div>
      </div>
    </div>
  </wa-dialog>
</div>

<script>
  // @ts-nocheck
  import '@awesome.me/webawesome/dist/components/dialog/dialog.js';
  import '@awesome.me/webawesome/dist/components/input/input.js';
  import '@awesome.me/webawesome/dist/components/icon/icon.js';
  import '@awesome.me/webawesome/dist/components/zoomable-frame/zoomable-frame.js';
  import Fuse from 'fuse.js'

  /** @type {HTMLInputElement | null} */
  let launcherInput;
  /** @type {HTMLElement | null} */
  let dialog;
  /** @type {HTMLInputElement | null} */
  let searchInput;
  /** @type {HTMLUListElement | null} */
  let resultsEl;
  /** @type {HTMLIFrameElement | null} */
  let previewIframe;

  /** @type {any} */
  let fuse = null; // Fuse instance
  /** @type {any[] | null} */
  let docs = null; // Loaded fuse.json array
  /** @type {number} */
  let selectedIndex = -1;
  /** @type {any[]} */
  let lastResults = [];
  /** @type {boolean} */
  let closing = false;
  /** @type {boolean} */
  let isOpen = false;
  /** @type {((this: HTMLInputElement, ev: Event) => any) | null} */
  let boundSearchInputHandler = null;

  // Transform MyST URLs to match site URL structure
  // For Insight Journal, URLs are already in the correct format: /browse/publication/{id}
  const transformMystUrl = (url) => {
    if (!url || url === '/') return url;
    // URLs from fuse.json are already correctly formatted, so just return as-is
    return url;
  };

  // Prefix relative root URLs with baseDir when present
  const prefixUrl = (url) => {
    if (!url) return url;
    // Do not prefix absolute or hash URLs
    if (/^(https?:)?\/\//.test(url) || url.startsWith('#')) return url;
    // URLs are already correctly formatted
    return transformMystUrl(url);
  };

  const refreshScopedRefs = () => {
    if (!dialog) return;
    searchInput = dialog.querySelector('.search-input');
    resultsEl = dialog.querySelector('.results');
    previewIframe = dialog.querySelector('.preview-iframe');
    // Bind close button to programmatic close to avoid overlay intercept issues
    const closeBtn = dialog.querySelector('button, wa-button');
    if (closeBtn) {
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        closeDialog();
      }, { once: false });
    }
  };

  const openDialog = () => {
    if (closing || isOpen) return; // don't open during close sequence or if already open
    // Get the dialog
    dialog = document.querySelector('.search-dialog') as HTMLElement;
    if (!dialog) return;

    refreshScopedRefs();

    // Attach input listeners scoped to this dialog instance
    if (searchInput) {
      boundSearchInputHandler ||= () => {
        const q = searchInput?.value || '';
        doSearch(q);
      };
      searchInput.addEventListener('input', boundSearchInputHandler, { once: false });
      // @ts-ignore
      searchInput.addEventListener('wa-input', boundSearchInputHandler, { once: false });
      // @ts-ignore
      searchInput.addEventListener('sl-input', boundSearchInputHandler, { once: false });
    }

    // Use component API to open; lifecycle events will update state
    try { (dialog as any).show?.(); } catch {}
    try { (dialog as any).open = true; } catch { dialog.setAttribute('open', ''); }
    ensureIndex();
  };

  const closeDialog = () => {
    closing = true;
    // Close the dialog using multiple approaches for mobile browser compatibility
    const dialogEl = document.querySelector('.search-dialog') as HTMLElement;
    if (dialogEl) {
      // Try Web Awesome component methods first
      try { (dialogEl as any).hide?.(); } catch {}

      // Force DOM attributes/properties (critical for mobile browsers)
      try { (dialogEl as any).open = false; } catch {}
      try { dialogEl.removeAttribute('open'); } catch {}
    }
    // Cleanup selection and results immediately; focus and flags handled on hide events
    selectedIndex = -1;
    renderResults([]);
  };

  const ensureIndex = async () => {
    if (fuse) return;
    try {
      const fuseUrl = '/fuse.json';
      console.log(`SearchDialog: Loading fuse index from ${fuseUrl}`);
      const res = await fetch(fuseUrl, { cache: 'force-cache' });
      if (!res.ok) {
        throw new Error(`Failed to fetch fuse.json: ${res.status} ${res.statusText}`);
      }
      docs = await res.json();
      console.log(`SearchDialog: Loaded ${docs.length} search entries`);
      // Configure keys with sensible weights
      const options = {
        includeScore: true,
        threshold: 0.4,
        ignoreLocation: true,
        minMatchCharLength: 2,
        keys: [
          { name: 'frontmatter.title', weight: 0.5 },
          { name: 'frontmatter.description', weight: 0.3 },
          { name: 'frontmatter.keywords', weight: 0.2 },
          { name: 'identifier', weight: 0.2 },
          { name: 'url', weight: 0.2 },
        ],
      };
      fuse = new Fuse(docs, options);
    } catch (e) {
      console.error('SearchDialog: Failed to load search index:', e);
      // You might want to show a user-friendly error message here
    }
  };

  /** @param {any[]} items */
  const renderResults = (items) => {
    if (!resultsEl) return;
    resultsEl.innerHTML = '';
    lastResults = items;
    items.forEach((it, idx) => {
      const entry = it.item || it; // Fuse result or raw item
      const li = document.createElement('li');
      li.className = 'result-item' + (idx === selectedIndex ? ' selected' : '');
      li.role = 'option';
      li.dataset.index = String(idx);
      // Ensure visibility for mobile browsers
      li.style.display = 'block';
      li.style.visibility = 'visible';
      li.style.opacity = '1';

      // Determine icon based on entry type/URL
      let icon = 'file-text';
      if (entry.kind === 'page' || entry.kind === 'document') icon = 'file-text';
      else if (entry.kind === 'heading') icon = 'heading';
      else if (entry.kind === 'table') icon = 'table';
      else if (entry.kind === 'figure') icon = 'image';
      else if (entry.url === '/') icon = 'house';
      else if (entry.url?.includes('component')) icon = 'puzzle-piece';

      li.innerHTML = `
  <div class="result-title"><wa-icon name="${icon}" aria-hidden="true"></wa-icon>&nbsp;&nbsp;<span>${escapeHtml(entry.frontmatter?.title || entry.title || entry.url)}</span></div>
        <div class="result-subtitle">
          ${entry.frontmatter?.description ? `<span>${escapeHtml(entry.frontmatter.description)}</span>` : ''}
        </div>
      `;
      li.addEventListener('click', () => navigateToIndex(idx));
      resultsEl.appendChild(li);
    });
    // Force visibility on the container after adding items
    if (resultsEl) {
      resultsEl.style.display = 'block';
      resultsEl.style.visibility = 'visible';
      resultsEl.style.opacity = '1';
    }
    updatePreview();
  };

  /** @param {string} query */
  const doSearch = async (query) => {
    if (!query || !query.trim()) {
      selectedIndex = -1;
      renderResults([]);
      return;
    }
    await ensureIndex();
    if (!fuse) return;
    const res = fuse.search(query, { limit: 100 });
    // Deduplicate by URL (fallback to identifier) keeping the first/highest-ranked hit
    const seen = new Set();
    const deduped = [];
    for (const r of res) {
      const entry = r && (r.item || r);
      const key = entry?.url || entry?.identifier;
      if (!key) {
        // If no stable key, include it once using object identity guard
        const sym = Symbol.for('no-key');
        if (!seen.has(sym)) { seen.add(sym); deduped.push(r); }
        continue;
      }
      if (seen.has(key)) continue;
      seen.add(key);
      deduped.push(r);
      if (deduped.length >= 10) break; // enforce display cap
    }
    selectedIndex = deduped.length ? 0 : -1;
    renderResults(deduped);
    scrollSelectedIntoView();
  };

  /** @param {number} idx */
  const navigateToIndex = (idx) => {
    const sel = lastResults[idx];
    const entry = sel?.item || sel;
    if (entry?.url) {
      console.log(`Navigating to: ${entry.url}`);
      window.location.href = prefixUrl(entry.url);
    }
  };

  const updatePreview = () => {
    if (!previewIframe) return;
    const sel = selectedIndex >= 0 ? lastResults[selectedIndex] : null;
    const entry = sel?.item || sel;
    const url = entry?.url || '';
    if (url) {
      previewIframe.src = prefixUrl(url);
    }
  };

  const scrollSelectedIntoView = () => {
    if (!resultsEl) return;
    const selEl = resultsEl.querySelector('.result-item.selected');
    if (selEl) selEl.scrollIntoView({ block: 'nearest' });
  };

  /** @param {string} str */
  const escapeHtml = (str) => str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');

  document.addEventListener('DOMContentLoaded', () => {
    launcherInput = document.querySelector('.search-launcher .nav-search');

  // Open dialog from launcher; guard against click-through just after a close
  if (launcherInput) {
    // Block pointerdown during the closing window to avoid click-through
    launcherInput.addEventListener('pointerdown', (e) => {
      if (closing) { e.preventDefault(); e.stopPropagation(); }
    }, { capture: true });
    launcherInput.addEventListener('click', (e) => {
      if (closing) { e.preventDefault(); e.stopPropagation(); return; }
      openDialog();
    });
  }

  // Global '/' shortcut to open search when not typing in an input/textarea
    /** @param {KeyboardEvent} e */
    const onGlobalKey = (e) => {
      if (e.key === '/' && !e.ctrlKey && !e.metaKey && !e.altKey) {
        // Don't re-open if already open
        // @ts-ignore
        if ((window as any).__searchOpened === true || closing === true) return;
        const tag = (document.activeElement?.tagName || '').toLowerCase();
        const active = /** @type {HTMLElement | null} */ (document.activeElement as any);
        if (tag !== 'input' && tag !== 'textarea' && active?.isContentEditable !== true) {
          e.preventDefault();
          openDialog();
        }
      }
    };
    window.addEventListener('keydown', onGlobalKey);

  // Search input typing (read value directly to avoid event typing issues)
  const handleInput = () => {
      const q = searchInput?.value || '';
      doSearch(q);
  };
  // Attach input listeners lazily on open when refs are scoped

    // Keyboard navigation inside dialog
    /** @param {KeyboardEvent} e */
    const onDialogKey = (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        closeDialog();
        return;
      }
      if (!lastResults.length) return;
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedIndex = (selectedIndex + 1) % lastResults.length;
        renderResults(lastResults);
        scrollSelectedIntoView();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedIndex = (selectedIndex - 1 + lastResults.length) % lastResults.length;
        renderResults(lastResults);
        scrollSelectedIntoView();
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (selectedIndex >= 0) navigateToIndex(selectedIndex);
      }
    };
    // Capture navigation keys at window level when dialog is open
    window.addEventListener('keydown', (e) => {
      // Delegate to dialog navigation only when the dialog is open
      // @ts-ignore
      if ((window as any).__searchOpened === true) onDialogKey(e);
    });

  // Zoom control removed; preview uses a fixed scale via CSS variable

    // Hook into dialog lifecycle events to set open/close flags reliably
    const markOpened = (ev?: Event) => {
      isOpen = true;
      closing = false;
      // Ensure results container visibility on mobile viewports
      if (resultsEl) {
        resultsEl.style.display = 'block';
        resultsEl.style.visibility = 'visible';
        resultsEl.style.opacity = '1';
        resultsEl.style.zIndex = '10';
        // Also ensure all result items are visible
        const items = resultsEl.querySelectorAll('.result-item');
        items.forEach(item => {
          (item as HTMLElement).style.display = 'block';
          (item as HTMLElement).style.visibility = 'visible';
          (item as HTMLElement).style.opacity = '1';
        });
      }
      setTimeout(() => searchInput?.focus(), 0);
      // @ts-ignore
      (window as any).__searchOpened = true;
    };
    const markClosed = (ev?: Event) => {
      isOpen = false;
      closing = false;
      // Detach input listeners to avoid duplicates on next open
      if (searchInput && boundSearchInputHandler) {
        searchInput.removeEventListener('input', boundSearchInputHandler);
        // @ts-ignore
        searchInput.removeEventListener('wa-input', boundSearchInputHandler);
        // @ts-ignore
        searchInput.removeEventListener('sl-input', boundSearchInputHandler);
        boundSearchInputHandler = null;
      }
      // Return focus to launcher for good keyboard UX
      launcherInput?.focus?.();
      // @ts-ignore
      (window as any).__searchOpened = false;
      dialog = null;

      // Force cleanup of any lingering open attributes on mobile browsers, but only if not reopening
      setTimeout(() => {
        const dialogEl = document.querySelector('.search-dialog') as HTMLElement;
        if (dialogEl && dialogEl.hasAttribute('open') && !isOpen && !closing) {
          dialogEl.removeAttribute('open');
          try { (dialogEl as any).open = false; } catch {}
        }
      }, 50);
    };
    // Attach to the dialog; simpler approach
    const dialogEl = document.querySelector('.search-dialog');
    if (dialogEl) {
      dialogEl.addEventListener('wa-show', markOpened);
      dialogEl.addEventListener('wa-after-show', markOpened);
      dialogEl.addEventListener('wa-hide', markClosed);
      dialogEl.addEventListener('wa-after-hide', markClosed);
      // Also listen for request-close events to proactively set the closing guard
      dialogEl.addEventListener('wa-request-close', () => { closing = true; });
      // Shoelace compatibility events
      // @ts-ignore
      dialogEl.addEventListener('sl-request-close', () => { closing = true; });
    }

    // Signal readiness for E2E tests
    // @ts-ignore
    (window as any).__searchReady = true;
  });


  // Expose minimal test hooks for E2E
  // @ts-ignore
  (window as any).__searchOpen = () => openDialog();
  // @ts-ignore
  (window as any).__searchClose = async () => {
    closeDialog();
    // For mobile browser compatibility, ensure dialog is actually closed
    // Use a more robust approach that checks both DOM state and component state
    await new Promise((resolve) => {
      let attempts = 0;
      const maxAttempts = 200; // 10 seconds max
      const checkClosed = () => {
        attempts++;
        const openDialogs = document.querySelectorAll('wa-dialog.search-dialog[open]');
        const componentClosed = (window as any).__searchOpened === false;

        if (openDialogs.length === 0 && componentClosed) {
          resolve(true);
        } else if (attempts >= maxAttempts) {
          // Force close if polling times out
          const dialogEl = document.querySelector('.search-dialog') as HTMLElement;
          if (dialogEl) {
            try { dialogEl.removeAttribute('open'); } catch {}
            try { (dialogEl as any).open = false; } catch {}
          }
          (window as any).__searchOpened = false;
          resolve(true);
        } else {
          setTimeout(checkClosed, 50);
        }
      };
      checkClosed();
    });
  };
  // @ts-ignore
  (window as any).__searchSetQuery = (q) => { try { if (searchInput) searchInput.value = String(q || ''); } catch {}; doSearch(String(q || '')); };
  // @ts-ignore
  (window as any).__searchResultsCount = () => Array.isArray(lastResults) ? lastResults.length : 0;
  // @ts-ignore
  (window as any).__searchSelectedUrl = () => { const sel = selectedIndex >= 0 ? lastResults[selectedIndex] : null; const entry = sel?.item || sel; return entry?.url || null; };
  // Also provide a prefixed variant for convenience in tests
  // @ts-ignore
  (window as any).__searchSelectedUrlPrefixed = () => { const sel = selectedIndex >= 0 ? lastResults[selectedIndex] : null; const entry = sel?.item || sel; return entry?.url ? prefixUrl(entry.url) : null; };
</script>

<style>
  /* Avoid force-showing the dialog; rely on the component's lifecycle */

  .search-launcher { width: 100%; }
  .nav-search { width: 100%; }
  .search-shortcut { font-family: var(--wa-font-family-code); font-size: var(--wa-font-size-xs); padding: var(--wa-space-3xs) var(--wa-space-2xs); background-color: var(--wa-color-neutral-fill-quiet); border: 1px solid var(--wa-color-neutral-border-normal); border-radius: var(--wa-border-radius-s); }

  .search-container { display: grid; grid-template-columns: 1fr; grid-template-rows: 1.62fr 1fr; gap: var(--wa-space-m); width: min(100%, 1100px); min-height: 70vh; --preview-scale: 0.5; position: relative; }
  .search-left { display: flex; flex-direction: column; gap: var(--wa-space-s); min-height: 0; overflow: visible; position: relative; z-index: 1; }
  .search-right { display: flex; flex-direction: column; gap: var(--wa-space-s); min-height: 0; }

  .search-top { display: flex; flex-direction: column; gap: var(--wa-space-2xs); }
  .keys-help { display: flex; flex-wrap: wrap; gap: var(--wa-space-m); color: var(--wa-color-text-quiet); font-size: var(--wa-font-size-s); margin-top: var(--wa-space-s); justify-content: center; }
  .keys-help kbd { font-family: var(--wa-font-family-code); padding: var(--wa-space-3xs) var(--wa-space-2xs); border: 1px solid var(--wa-color-neutral-border-normal); border-radius: var(--wa-border-radius-s); background: var(--wa-color-neutral-fill-quiet); }

  .results { list-style: none; margin: 0; padding: 0; overflow: auto; border: 1px solid var(--wa-color-surface-border); border-radius: var(--wa-border-radius-m); flex: 1; min-height: 200px; display: block !important; visibility: visible !important; position: relative; z-index: 2; }

  .preview-header { display: flex; justify-content: space-between; align-items: center; }
  .preview-frame { position: relative; overflow: auto; border: 1px solid var(--wa-color-surface-border); border-radius: var(--wa-border-radius-m); flex: 1; }
  .preview-iframe { width: 100%; height: 100%; }

  /* Single-column layout already places preview below results on all viewports */
</style>

<style is:global>
  /* Global styles for JavaScript-manipulated classes */
  .result-item.selected {
    background: var(--wa-color-brand-fill-quiet);
    color: var(--wa-color-brand-on-quiet);
  }
  .result-item { padding: var(--wa-space-s); border-bottom: 1px solid var(--wa-color-surface-border); cursor: pointer; display: block !important; visibility: visible !important; position: relative; }
  .result-item:last-child { border-bottom: none; }
  .result-title { font-weight: var(--wa-font-weight-semibold); display: block; }
  .result-subtitle { color: var(--wa-color-text-quiet); font-size: var(--wa-font-size-s); display: flex; gap: var(--wa-space-xs); flex-wrap: wrap; }
</style>
